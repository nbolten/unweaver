{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Unweaver Unweaver is a flexible routing engine intended for research and production routing and network analysis applications. Why use Unweaver? Unweaver stitches together a routable network from geospatial data and stores it as a routable GeoPackage, a portable SQLite database and OGC standard. You can save, share, and query your networks using any open source tooling that understands SQLite or GeoPackages. Unweaver leverages user-defined Python cost functions that are evaluated at runtime, so you can define and rapidly iterate on your shortest-path graph traversal using any amount of custom logic. Unweaver provides a networkx -compatible view into your routable GeoPackage so that you can traverse and query it like an in-memory graph*. Unweaver provides a web server that creates JSON-returning web endpoints using simple JSON configuration files (routing profiles). Unweaver can be used as a command line tool or as a library in production applications or Jupyter notebooks. * Not all networkx algorithms have been tested with Unweaver yet. Commands unweaver build - Build a project directory into a routable GeoPackage. unweaver weight - Calculate static weights for edges in the routable GeoPackage. unweaver serve - Start the web API server (shortest-path, shortest-path tree, and reachable tree JSON endpoints). mkdocs --help - Print help message and exit. Project layout mkdocs.yml # The configuration file. poetry.lock # Python dependencies lockfile. pyproject.toml # Primary package definition config. CONTRIBUTING.md # Documentation for contributing to unweaver. Dockerfile # For reproducible builds and deployments with `docker`. LICENSE # The license for unweaver (Apache-2.0). README.md # README for the unweaver. TODO.md # Project planning (for lack of a Kanban...). docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. example/ ... # Example unweaver project directory contents tests/ # Project tests (for development) unweaver/ # The unweaver library","title":"Home"},{"location":"#welcome-to-unweaver","text":"Unweaver is a flexible routing engine intended for research and production routing and network analysis applications. Why use Unweaver? Unweaver stitches together a routable network from geospatial data and stores it as a routable GeoPackage, a portable SQLite database and OGC standard. You can save, share, and query your networks using any open source tooling that understands SQLite or GeoPackages. Unweaver leverages user-defined Python cost functions that are evaluated at runtime, so you can define and rapidly iterate on your shortest-path graph traversal using any amount of custom logic. Unweaver provides a networkx -compatible view into your routable GeoPackage so that you can traverse and query it like an in-memory graph*. Unweaver provides a web server that creates JSON-returning web endpoints using simple JSON configuration files (routing profiles). Unweaver can be used as a command line tool or as a library in production applications or Jupyter notebooks. * Not all networkx algorithms have been tested with Unweaver yet.","title":"Welcome to Unweaver"},{"location":"#commands","text":"unweaver build - Build a project directory into a routable GeoPackage. unweaver weight - Calculate static weights for edges in the routable GeoPackage. unweaver serve - Start the web API server (shortest-path, shortest-path tree, and reachable tree JSON endpoints). mkdocs --help - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. poetry.lock # Python dependencies lockfile. pyproject.toml # Primary package definition config. CONTRIBUTING.md # Documentation for contributing to unweaver. Dockerfile # For reproducible builds and deployments with `docker`. LICENSE # The license for unweaver (Apache-2.0). README.md # README for the unweaver. TODO.md # Project planning (for lack of a Kanban...). docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. example/ ... # Example unweaver project directory contents tests/ # Project tests (for development) unweaver/ # The unweaver library","title":"Project layout"},{"location":"cli-reference/","text":"CLI Reference unweaver Usage: unweaver [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. build Build a routable GeoPackage (graph.gpkg in the project directory) from the data in the {project}/layers directory. Usage: unweaver build [OPTIONS] PROJECT_DIRECTORY Options: --precision INTEGER Latitude-longitude coordinate rounding precision for whether dataset polylines are connected. --changes-sign TEXT A property whose sign should be flipped when reversing an edge. Example: a positive steepness/incline field value should be made negative for the reverse edge. --help Show this message and exit. serve Run a web server with auto-generated web API endpoints that return JSON for shortest-path routes, shortest-path trees, and reachable trees for every profile in a project. Usage: unweaver serve [OPTIONS] PROJECT_DIRECTORY Options: -h, --host TEXT Host on which to run the server. -p, --port INTEGER Port on which to run the server. --debug Whether to run the server with in-browser error tracebacks. --help Show this message and exit. weight Precalculate all static weights for all profiles in a project. Usage: unweaver weight [OPTIONS] PROJECT_DIRECTORY Options: --help Show this message and exit.","title":"CLI Reference"},{"location":"cli-reference/#cli-reference","text":"","title":"CLI Reference"},{"location":"cli-reference/#unweaver","text":"Usage: unweaver [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit.","title":"unweaver"},{"location":"cli-reference/#build","text":"Build a routable GeoPackage (graph.gpkg in the project directory) from the data in the {project}/layers directory. Usage: unweaver build [OPTIONS] PROJECT_DIRECTORY Options: --precision INTEGER Latitude-longitude coordinate rounding precision for whether dataset polylines are connected. --changes-sign TEXT A property whose sign should be flipped when reversing an edge. Example: a positive steepness/incline field value should be made negative for the reverse edge. --help Show this message and exit.","title":"build"},{"location":"cli-reference/#serve","text":"Run a web server with auto-generated web API endpoints that return JSON for shortest-path routes, shortest-path trees, and reachable trees for every profile in a project. Usage: unweaver serve [OPTIONS] PROJECT_DIRECTORY Options: -h, --host TEXT Host on which to run the server. -p, --port INTEGER Port on which to run the server. --debug Whether to run the server with in-browser error tracebacks. --help Show this message and exit.","title":"serve"},{"location":"cli-reference/#weight","text":"Precalculate all static weights for all profiles in a project. Usage: unweaver weight [OPTIONS] PROJECT_DIRECTORY Options: --help Show this message and exit.","title":"weight"},{"location":"configure-a-project/","text":"Create a project An unweaver project is a directory that contains all of the configuration files and data needed to run or deploy unweaver. An unweaver project must contain a layers directory with at least one GDAL-readable LineString dataset and a profile.json with an id attribute. Project directory layout layers/ ...: # One or more GDAL-readable file (GeoJSON) of LineString data. cost-*.py # (optional) A Python module that defines a cost function generator. shortest-path-*.py # (optional) A Python module that defines a shortest path result function. profile-*.json # A JSON configuration file that defines combinations of other user-defined elements. The layers directory Unweaver builds a routable network that's stored as a GeoPackage based on geospatial input data that's placed into a the layers directory of a project. The geospatial data files must contain LineString geometries and readable by GDAL, which includes GeoJSON and shapefiles. In order to be built into a network, these geometries will be connected end-to-end based on spatial proximity (the proximity tolerance is configurable during the build process and defaults to ~10 centimeters). Profiles Any file that follows the pattern profile-*.json will be assumed to be a JSON configuration file defining an Unweaver profile. An Unweaver profile JSON ties together a set of user-definable prefences that are intended to be used together; since Unweaver allows a user to define multiple cost functions, shortest path result functions, shortest path tree functions, and runtime parameters for their cost functions, there is a need to declare which exact set should be used for a given purpose, such as running the Unweaver web server and providing shortest path routes. An Unweaver profile also provides a flexible way in which to alternatively hard-code some of the arguments to a user-defined cost function and to declare that a given profile should be used to precalculate static edge traversal weights using a cost function and hard-coded cost function arguments. An Unweaver profile has the following layout: { \"id\": string, # A unique identifier (and name) for this profile. \"args\": [ # A list of runtime arguments for parameterizing the cost function. { \"name\": string, # The name of this runtime argument \"type\": Marshmallow field string # A string containing a Marshmallow field. }, ..., ], \"precalculate\": boolean # Whether to precalculate static weights for this profile. \"static\": { str: value # Hard-coded arguments for the cost function (useful if precalculate is true). }, \"cost_function\": string # The Python module filename for a cost function. \"shortest_path\": string # The Python module filename for a shortest path result function. \"shortest_path_tree\": string # The Python module filename for a shortest path tree result function. \"reachable_tree\": string # The Python module filename for a reachable paths result function. } For example: { \"id\": \"example\", \"args\": [ { \"name\": \"pedestrianMode\", \"type\": \"fields.Boolean()\" } ], \"cost_function\": \"cost-flexible.py\", \"shortest_path\": \"shortest-path-best.py\" } Or for the same profile, but with precalculated weights: { \"id\": \"example-pedestrian\", \"static\": { \"pedestrianMode\": true }, \"cost_function\": \"cost-flexible.py\", \"shortest_path\": \"shortest-path-best.py\" } Nearly all of the top-level fields that can be set in an Unweaver profile have default fallback settings, so the only part of an Unweaver profile that must be set is the id field. Therefore, this is a valid profile: { \"id\": \"test\" } It will use the cost function, directions function, shortest paths function, and reachable function defines in the unweaver/default_profile_functions.py module. The meaning and use of the various user-defined function modules that may be referenced by an Unweaver profile will be covered in the next sections. Cost functions Any file that follows the pattern cost-*.py will be assumed to be a Python module that defines a \"cost function generator\", a function with the following signature: def cost_function_generator(G: DiGraphGPKGView, **kwargs: Any) -> Callable[[str, str, dict], Optional[float]]: Where G is a view on the entire routable graph, kwargs are named parameters and are any user-defined inputs needed at runtime by the Unweaver web server (you can also define no arguments for this function) and Callable[[str, str, dict], Optional[float]] is a networkx shortest-path algorithm-compatible cost function. Specifically, networkx shortest-path algorithms expect a cost function to accept the start node ( u , in this case a string), the end node ( v , also a string), and an edge data dictionary ( d , a dictionary of your geospatial data's per-LineString feature properties). Shortest path Any file that follows the pattern shortest-path-*.py will be assumed to be a Python module that defines a directions result function, which is a function with the following signature: def shortest_path( status: str, G: DiGraphGPKG, origin: Feature[Point], destination: Feature[Point], cost: Optional[float], nodes: ReachedNodes, edges: List[EdgeData], ) -> dict: This function allows you to completely customize the directions JSON response returned by the Unweaver web API for a given profile. It is sent a given a large amount of context that it can use to query for information about a shortest path result, including the entire graph (a DiGraphGPKG ), and returns a dictionary that will be converted into JSON. Shortest path trees Any file that follows the pattern shortest-path-tree-*.py will be assumed to be a Python module that defines a shortest paths tree result function, which is a function with the following signature: def shortest_path_tree( status: str, G: DiGraphGPKGView, origin: Feature[Point], nodes: ReachedNodes, paths: Paths, edges: List[EdgeData], ) -> dict: This function allows you to completely customize the shortest path tree JSON response returned by the Unweaver web API for a given profile. Like the directions function, it is provided with a large amount of context in addition to the result. Reachable tree Any file that follows the pattern reachable-tree-*.py will be assumed to be a Python module that defines a reachable paths tree result function, which is a function with the following signature: def reachable_tree( status: str, G: DiGraphGPKGView, origin: Feature[Point], nodes: ReachedNodes, edges: List[EdgeData], ) -> dict: This function allows you to completely customize the reachable paths tree JSON response returned by the Unweaver web API for a given profile. Like the directions function, it is provided with a large amount of context in addition to the result.","title":"Configure a project"},{"location":"configure-a-project/#create-a-project","text":"An unweaver project is a directory that contains all of the configuration files and data needed to run or deploy unweaver. An unweaver project must contain a layers directory with at least one GDAL-readable LineString dataset and a profile.json with an id attribute.","title":"Create a project"},{"location":"configure-a-project/#project-directory-layout","text":"layers/ ...: # One or more GDAL-readable file (GeoJSON) of LineString data. cost-*.py # (optional) A Python module that defines a cost function generator. shortest-path-*.py # (optional) A Python module that defines a shortest path result function. profile-*.json # A JSON configuration file that defines combinations of other user-defined elements.","title":"Project directory layout"},{"location":"configure-a-project/#the-layers-directory","text":"Unweaver builds a routable network that's stored as a GeoPackage based on geospatial input data that's placed into a the layers directory of a project. The geospatial data files must contain LineString geometries and readable by GDAL, which includes GeoJSON and shapefiles. In order to be built into a network, these geometries will be connected end-to-end based on spatial proximity (the proximity tolerance is configurable during the build process and defaults to ~10 centimeters).","title":"The layers directory"},{"location":"configure-a-project/#profiles","text":"Any file that follows the pattern profile-*.json will be assumed to be a JSON configuration file defining an Unweaver profile. An Unweaver profile JSON ties together a set of user-definable prefences that are intended to be used together; since Unweaver allows a user to define multiple cost functions, shortest path result functions, shortest path tree functions, and runtime parameters for their cost functions, there is a need to declare which exact set should be used for a given purpose, such as running the Unweaver web server and providing shortest path routes. An Unweaver profile also provides a flexible way in which to alternatively hard-code some of the arguments to a user-defined cost function and to declare that a given profile should be used to precalculate static edge traversal weights using a cost function and hard-coded cost function arguments. An Unweaver profile has the following layout: { \"id\": string, # A unique identifier (and name) for this profile. \"args\": [ # A list of runtime arguments for parameterizing the cost function. { \"name\": string, # The name of this runtime argument \"type\": Marshmallow field string # A string containing a Marshmallow field. }, ..., ], \"precalculate\": boolean # Whether to precalculate static weights for this profile. \"static\": { str: value # Hard-coded arguments for the cost function (useful if precalculate is true). }, \"cost_function\": string # The Python module filename for a cost function. \"shortest_path\": string # The Python module filename for a shortest path result function. \"shortest_path_tree\": string # The Python module filename for a shortest path tree result function. \"reachable_tree\": string # The Python module filename for a reachable paths result function. } For example: { \"id\": \"example\", \"args\": [ { \"name\": \"pedestrianMode\", \"type\": \"fields.Boolean()\" } ], \"cost_function\": \"cost-flexible.py\", \"shortest_path\": \"shortest-path-best.py\" } Or for the same profile, but with precalculated weights: { \"id\": \"example-pedestrian\", \"static\": { \"pedestrianMode\": true }, \"cost_function\": \"cost-flexible.py\", \"shortest_path\": \"shortest-path-best.py\" } Nearly all of the top-level fields that can be set in an Unweaver profile have default fallback settings, so the only part of an Unweaver profile that must be set is the id field. Therefore, this is a valid profile: { \"id\": \"test\" } It will use the cost function, directions function, shortest paths function, and reachable function defines in the unweaver/default_profile_functions.py module. The meaning and use of the various user-defined function modules that may be referenced by an Unweaver profile will be covered in the next sections.","title":"Profiles"},{"location":"configure-a-project/#cost-functions","text":"Any file that follows the pattern cost-*.py will be assumed to be a Python module that defines a \"cost function generator\", a function with the following signature: def cost_function_generator(G: DiGraphGPKGView, **kwargs: Any) -> Callable[[str, str, dict], Optional[float]]: Where G is a view on the entire routable graph, kwargs are named parameters and are any user-defined inputs needed at runtime by the Unweaver web server (you can also define no arguments for this function) and Callable[[str, str, dict], Optional[float]] is a networkx shortest-path algorithm-compatible cost function. Specifically, networkx shortest-path algorithms expect a cost function to accept the start node ( u , in this case a string), the end node ( v , also a string), and an edge data dictionary ( d , a dictionary of your geospatial data's per-LineString feature properties).","title":"Cost functions"},{"location":"configure-a-project/#shortest-path","text":"Any file that follows the pattern shortest-path-*.py will be assumed to be a Python module that defines a directions result function, which is a function with the following signature: def shortest_path( status: str, G: DiGraphGPKG, origin: Feature[Point], destination: Feature[Point], cost: Optional[float], nodes: ReachedNodes, edges: List[EdgeData], ) -> dict: This function allows you to completely customize the directions JSON response returned by the Unweaver web API for a given profile. It is sent a given a large amount of context that it can use to query for information about a shortest path result, including the entire graph (a DiGraphGPKG ), and returns a dictionary that will be converted into JSON.","title":"Shortest path"},{"location":"configure-a-project/#shortest-path-trees","text":"Any file that follows the pattern shortest-path-tree-*.py will be assumed to be a Python module that defines a shortest paths tree result function, which is a function with the following signature: def shortest_path_tree( status: str, G: DiGraphGPKGView, origin: Feature[Point], nodes: ReachedNodes, paths: Paths, edges: List[EdgeData], ) -> dict: This function allows you to completely customize the shortest path tree JSON response returned by the Unweaver web API for a given profile. Like the directions function, it is provided with a large amount of context in addition to the result.","title":"Shortest path trees"},{"location":"configure-a-project/#reachable-tree","text":"Any file that follows the pattern reachable-tree-*.py will be assumed to be a Python module that defines a reachable paths tree result function, which is a function with the following signature: def reachable_tree( status: str, G: DiGraphGPKGView, origin: Feature[Point], nodes: ReachedNodes, edges: List[EdgeData], ) -> dict: This function allows you to completely customize the reachable paths tree JSON response returned by the Unweaver web API for a given profile. Like the directions function, it is provided with a large amount of context in addition to the result.","title":"Reachable tree"},{"location":"getting-started/","text":"Installation With Docker docker build -t unweaver https://github.com/nbolten/unweaver.git#main With pip or poetry Non-Python prerequisites Unweaver depends on the following software packages in order to run: SQLite: A file-based SQL database and the format of the routable GeoPackage created by unweaver . SpatiaLite: An extension for SQLite that adds geospatial support. GDAL: A common geospatial library for reading/writing geodata formats. proj4: A common geospatial library for managing map (re)projections. Platform-specific prerequisites installation On a Mac using Homebrew: brew install sqlite libspatialite gdal proj (See this troubleshooting on Mac section if you still can't load SQLite extensions with unweaver ) On a debian-based distribution: apt install libsqlite3 libspatialite libgdal libproj Enable SQLite extension support in Python Python may be distributed with or without SQLite and extensions support. For example, if you are using pyenv to manage your Python installation, you will need to ensure it is built with flags enable SQLite support. Unweaver is build with the poetry toolkit. When Unweaver is properly released on PyPI, installing the module will be as simple as running poetry add unweaver . For now, it must be installed from this repository. This can be done using either with poetry (ideal) or pip (for backwards compatibility). With pip : This can be done with a one-liner: pip install git+https://github.com/nbolten/unweaver.git@f9f4bed#egg=unweaver Where the @ entry is the commit. This can also be set to a branch name. With poetry : Edit your pyproject.toml to include a line like this under [tool.poetry.dependencies]: unweaver = {git = \"https://github.com/nbolten/unweaver.git\", rev = \"f9f4bed\"} You can choose rev to be whatever git commit hash you want to use.","title":"Installation"},{"location":"getting-started/#installation","text":"","title":"Installation"},{"location":"getting-started/#with-docker","text":"docker build -t unweaver https://github.com/nbolten/unweaver.git#main","title":"With Docker"},{"location":"getting-started/#with-pip-or-poetry","text":"","title":"With pip or poetry"},{"location":"getting-started/#non-python-prerequisites","text":"Unweaver depends on the following software packages in order to run: SQLite: A file-based SQL database and the format of the routable GeoPackage created by unweaver . SpatiaLite: An extension for SQLite that adds geospatial support. GDAL: A common geospatial library for reading/writing geodata formats. proj4: A common geospatial library for managing map (re)projections.","title":"Non-Python prerequisites"},{"location":"getting-started/#platform-specific-prerequisites-installation","text":"On a Mac using Homebrew: brew install sqlite libspatialite gdal proj (See this troubleshooting on Mac section if you still can't load SQLite extensions with unweaver ) On a debian-based distribution: apt install libsqlite3 libspatialite libgdal libproj","title":"Platform-specific prerequisites installation"},{"location":"getting-started/#enable-sqlite-extension-support-in-python","text":"Python may be distributed with or without SQLite and extensions support. For example, if you are using pyenv to manage your Python installation, you will need to ensure it is built with flags enable SQLite support. Unweaver is build with the poetry toolkit. When Unweaver is properly released on PyPI, installing the module will be as simple as running poetry add unweaver . For now, it must be installed from this repository. This can be done using either with poetry (ideal) or pip (for backwards compatibility).","title":"Enable SQLite extension support in Python"},{"location":"getting-started/#with-pip","text":"This can be done with a one-liner: pip install git+https://github.com/nbolten/unweaver.git@f9f4bed#egg=unweaver Where the @ entry is the commit. This can also be set to a branch name.","title":"With pip:"},{"location":"getting-started/#with-poetry","text":"Edit your pyproject.toml to include a line like this under [tool.poetry.dependencies]: unweaver = {git = \"https://github.com/nbolten/unweaver.git\", rev = \"f9f4bed\"} You can choose rev to be whatever git commit hash you want to use.","title":"With poetry:"},{"location":"library-build/","text":"Reference Build unweaver . build . build_graph . build_graph ( path , precision = 7 , changes_sign = None , counter = None ) Build a graph in a project directory. Parameters: Name Type Description Default path str Path to the project directory. required precision int Rounding precision for whether to connect two LineStrings end-to-end. Defaults to about 10 cm. 7 changes_sign Optional [ List [ str ]] A list of numeric edge fields whose values should change sign when traversed in the \"reverse\" direction. An incline value is an example of this: uphill is positive, downhill negative. None counter Optional [ ProgressBar ] An optional Click counter. None Source code in unweaver/build/build_graph.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def build_graph ( path : str , precision : int = 7 , changes_sign : Optional [ List [ str ]] = None , counter : Optional [ ProgressBar ] = None , ) -> DiGraphGPKG : \"\"\"Build a graph in a project directory. :param path: Path to the project directory. :param precision: Rounding precision for whether to connect two LineStrings end-to-end. Defaults to about 10 cm. :param changes_sign: A list of numeric edge fields whose values should change sign when traversed in the \"reverse\" direction. An incline value is an example of this: uphill is positive, downhill negative. :param counter: An optional Click counter. \"\"\" builder = GraphBuilder ( precision = precision , changes_sign = changes_sign ) paths = get_layers_paths ( path ) db_path = os . path . join ( path , DB_PATH ) for path in paths : builder . add_edges_from ( path , counter = counter ) builder . finalize_db ( db_path ) return builder . G","title":"Build"},{"location":"library-build/#reference","text":"","title":"Reference"},{"location":"library-build/#build","text":"","title":"Build"},{"location":"library-build/#unweaver.build.build_graph.build_graph","text":"Build a graph in a project directory. Parameters: Name Type Description Default path str Path to the project directory. required precision int Rounding precision for whether to connect two LineStrings end-to-end. Defaults to about 10 cm. 7 changes_sign Optional [ List [ str ]] A list of numeric edge fields whose values should change sign when traversed in the \"reverse\" direction. An incline value is an example of this: uphill is positive, downhill negative. None counter Optional [ ProgressBar ] An optional Click counter. None Source code in unweaver/build/build_graph.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def build_graph ( path : str , precision : int = 7 , changes_sign : Optional [ List [ str ]] = None , counter : Optional [ ProgressBar ] = None , ) -> DiGraphGPKG : \"\"\"Build a graph in a project directory. :param path: Path to the project directory. :param precision: Rounding precision for whether to connect two LineStrings end-to-end. Defaults to about 10 cm. :param changes_sign: A list of numeric edge fields whose values should change sign when traversed in the \"reverse\" direction. An incline value is an example of this: uphill is positive, downhill negative. :param counter: An optional Click counter. \"\"\" builder = GraphBuilder ( precision = precision , changes_sign = changes_sign ) paths = get_layers_paths ( path ) db_path = os . path . join ( path , DB_PATH ) for path in paths : builder . add_edges_from ( path , counter = counter ) builder . finalize_db ( db_path ) return builder . G","title":"build_graph()"},{"location":"library-geopackage/","text":"Reference GeoPackage unweaver.geopackage.GeoPackage A Python interface to a GeoPackage, an SQLite-format OGC standard for geospatial vector data. Parameters: Name Type Description Default path str Path to a GeoPackage (ends with .gpkg). If the path does not exist, it will be created. None Source code in unweaver/geopackage/geopackage.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 class GeoPackage : \"\"\"A Python interface to a GeoPackage, an SQLite-format OGC standard for geospatial vector data. :param path: Path to a GeoPackage (ends with .gpkg). If the path does not exist, it will be created. \"\"\" VERSION = 0 EMPTY = 1 def __init__ ( self , path : str = None ): if path is None : # TODO: revisit this behavior. Creating a temporary file by default # may be undesirable. # Create a temporary path, get the name _ , path = tempfile . mkstemp ( suffix = \".gpkg\" ) self . path = str ( path ) # Delete the path to prepare for fresh db os . remove ( path ) else : self . path = path self . _setup_database () self . feature_tables = {} # Instantiate FeatureTables that already exist in the db with self . connect () as conn : query_result = conn . execute ( \"SELECT table_name, srs_id FROM gpkg_contents\" ) table_rows = list ( query_result ) for row in table_rows : table_name = row [ \"table_name\" ] with self . connect () as conn : geom_type_query = conn . execute ( \"\"\" SELECT geometry_type_name FROM gpkg_geometry_columns WHERE table_name = ? \"\"\" , ( table_name ,), ) geom_type = next ( geom_type_query )[ \"geometry_type_name\" ] enum_geom_type = getattr ( GeoPackageGeoms , geom_type ) self . feature_tables [ table_name ] = FeatureTable ( self , table_name , enum_geom_type , srid = row [ \"srs_id\" ] ) def add_feature_table ( self , name : str , geom_type : GeoPackageGeoms , srid : int = 4326 ) -> FeatureTable : \"\"\"Create a new layer (feature table) in the GeoPackage. :param name: Name of the new layer. :param geom_type: Geometry type of the new layer. :srid: SRID (projection). \"\"\" table = FeatureTable ( self , name , geom_type , srid = srid ) table . create_tables () self . feature_tables [ name ] = table return table def drop_feature_table ( self , name : str ) -> None : \"\"\"Delete a layer (feature table) by name. :param name: Name of the layer. \"\"\" table = self . feature_tables . pop ( name ) table . drop_tables () def _is_connected ( self ) -> bool : try : self . conn . cursor () return True except Exception : return False def _get_connection ( self ) -> None : if not self . _is_connected (): conn = sqlite3 . connect ( self . path , uri = True , isolation_level = None ) # Spatialite used for rtree-based functions (MinX, etc). Can # eventually replace or make configurable with other extensions. conn . load_extension ( \"mod_spatialite.so\" ) conn . row_factory = self . _dict_factory self . conn = conn @contextlib . contextmanager def connect ( self ) -> Generator [ sqlite3 . Connection , None , None ]: self . _get_connection () yield self . conn def _setup_database ( self ) -> None : if self . _is_empty_database (): self . _create_database () def _is_empty_database ( self ) -> bool : is_empty = True with self . connect () as conn : query_result = conn . execute ( \"SELECT name FROM sqlite_master WHERE type = 'table'\" ) try : next ( query_result ) is_empty = False except StopIteration : is_empty = True return is_empty def _create_database ( self ) -> None : with self . connect () as conn : # Set the format metadata conn . execute ( f \"PRAGMA application_id = { GPKG_APPLICATION_ID } \" ) conn . execute ( f \"PRAGMA user_version = { GPKG_USER_VERSION } \" ) # Create gpkg_contents table conn . execute ( \"\"\" CREATE TABLE IF NOT EXISTS gpkg_contents ( table_name TEXT, data_type TEXT NOT NULL, identifier TEXT UNIQUE, description TEXT DEFAULT '', last_change TIMESTAMP DEFAULT CURRENT_TIMESTAMP, min_x DOUBLE, min_y DOUBLE, max_x DOUBLE, max_y DOUBLE, srs_id INTEGER, PRIMARY KEY (table_name) ) \"\"\" ) # Create gpkg_extensions table conn . execute ( \"\"\" CREATE TABLE IF NOT EXISTS gpkg_extensions( table_name TEXT, column_name TEXT, extension_name TEXT NOT NULL, definition TEXT NOT NULL, scope TEXT NOT NULL, UNIQUE (table_name, column_name, extension_name) ) \"\"\" ) # Create gpkg_geometry_columns table conn . execute ( \"\"\" CREATE TABLE IF NOT EXISTS gpkg_geometry_columns( table_name TEXT UNIQUE NOT NULL, column_name TEXT NOT NULL, geometry_type_name TEXT NOT NULL, srs_id INTEGER NOT NULL, z TINYINT NOT NULL, m TINYINT NOT NULL, PRIMARY KEY (table_name, column_name) ) \"\"\" ) # Create gpkg_ogr_contents table conn . execute ( \"\"\" CREATE TABLE IF NOT EXISTS gpkg_ogr_contents( table_name TEXT NOT NULL, feature_count INTEGER DEFAULT NULL, PRIMARY KEY (table_name) ) \"\"\" ) # Create gpkg_spatial_ref_sys conn . execute ( \"\"\" CREATE TABLE IF NOT EXISTS gpkg_spatial_ref_sys( srs_name TEXT NOT NULL, srs_id INTEGER NOT NULL, organization TEXT NOT NULL, organization_coordsys_id INTEGER NOT NULL, definition TEXT NOT NULL, description TEXT, PRIMARY KEY (srs_id) ) \"\"\" ) def copy ( self , path : str ) -> GeoPackage : \"\"\"Copies the current GeoPackage to a new location and returns a new instance of a GeoPackage. A convenient way to create an in-memory GeoPackage, as path can be any SQLite-compatible connection string, including :memory:. :param path: Path to the new database. Any SQLite connection string can be used. \"\"\" # TODO: catch the \"memory\" string and ensure that it includes a name # and shared cache. Our strategy requires reconnecting to the db, # so it must persist in memory. new_conn = sqlite3 . connect ( path ) new_conn . enable_load_extension ( True ) # Spatialite used for rtree-based functions (MinX, etc). Can eventually # replace or make configurable with other extensions. new_conn . load_extension ( \"mod_spatialite.so\" ) with self . connect () as conn : # Set row_factory to none for iterdumping conn . row_factory = None # Copy over all tables but not indices for line in conn . iterdump (): # Skip all index creation - these should be recreated # afterwards if \"CREATE TABLE\" in line or \"INSERT INTO\" in line : # TODO: derive index names from metadata table instead if \"idx_\" in line : continue if \"rtree_\" in line : continue if \"COMMIT\" in line : continue new_conn . cursor () . executescript ( line ) # Copy over all indices for line in conn . iterdump (): # Recreate the indices if \"CREATE TABLE\" in line or \"INSERT INTO\" in line : if \"idx_\" in line : new_conn . cursor () . executescript ( line ) if \"COMMIT\" in line : continue # TODO: rtree strategy is different? Why? # for line in conn.iterdump(): # # Recreate the indices # if \"CREATE TABLE\" in line or \"INSERT INTO\" in line: # if \"rtree_\" in line: # new_conn.cursor().executescript(line) # if \"COMMIT\" in line: # continue conn . row_factory = self . _dict_factory new_db = GeoPackage ( path ) return new_db # TODO: Instead of 'Any', use Python types that can be deserialized from # sqlite @staticmethod def _dict_factory ( cursor : sqlite3 . Cursor , row : sqlite3 . Row ) -> Dict [ str , Any ]: return { col [ 0 ]: row [ idx ] for idx , col in enumerate ( cursor . description )} add_feature_table ( name , geom_type , srid = 4326 ) Create a new layer (feature table) in the GeoPackage. :srid: SRID (projection). Parameters: Name Type Description Default name str Name of the new layer. required geom_type GeoPackageGeoms Geometry type of the new layer. required Source code in unweaver/geopackage/geopackage.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def add_feature_table ( self , name : str , geom_type : GeoPackageGeoms , srid : int = 4326 ) -> FeatureTable : \"\"\"Create a new layer (feature table) in the GeoPackage. :param name: Name of the new layer. :param geom_type: Geometry type of the new layer. :srid: SRID (projection). \"\"\" table = FeatureTable ( self , name , geom_type , srid = srid ) table . create_tables () self . feature_tables [ name ] = table return table copy ( path ) Copies the current GeoPackage to a new location and returns a new instance of a GeoPackage. A convenient way to create an in-memory GeoPackage, as path can be any SQLite-compatible connection string, including :memory:. Parameters: Name Type Description Default path str Path to the new database. Any SQLite connection string can be used. required Source code in unweaver/geopackage/geopackage.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def copy ( self , path : str ) -> GeoPackage : \"\"\"Copies the current GeoPackage to a new location and returns a new instance of a GeoPackage. A convenient way to create an in-memory GeoPackage, as path can be any SQLite-compatible connection string, including :memory:. :param path: Path to the new database. Any SQLite connection string can be used. \"\"\" # TODO: catch the \"memory\" string and ensure that it includes a name # and shared cache. Our strategy requires reconnecting to the db, # so it must persist in memory. new_conn = sqlite3 . connect ( path ) new_conn . enable_load_extension ( True ) # Spatialite used for rtree-based functions (MinX, etc). Can eventually # replace or make configurable with other extensions. new_conn . load_extension ( \"mod_spatialite.so\" ) with self . connect () as conn : # Set row_factory to none for iterdumping conn . row_factory = None # Copy over all tables but not indices for line in conn . iterdump (): # Skip all index creation - these should be recreated # afterwards if \"CREATE TABLE\" in line or \"INSERT INTO\" in line : # TODO: derive index names from metadata table instead if \"idx_\" in line : continue if \"rtree_\" in line : continue if \"COMMIT\" in line : continue new_conn . cursor () . executescript ( line ) # Copy over all indices for line in conn . iterdump (): # Recreate the indices if \"CREATE TABLE\" in line or \"INSERT INTO\" in line : if \"idx_\" in line : new_conn . cursor () . executescript ( line ) if \"COMMIT\" in line : continue # TODO: rtree strategy is different? Why? # for line in conn.iterdump(): # # Recreate the indices # if \"CREATE TABLE\" in line or \"INSERT INTO\" in line: # if \"rtree_\" in line: # new_conn.cursor().executescript(line) # if \"COMMIT\" in line: # continue conn . row_factory = self . _dict_factory new_db = GeoPackage ( path ) return new_db drop_feature_table ( name ) Delete a layer (feature table) by name. Parameters: Name Type Description Default name str Name of the layer. required Source code in unweaver/geopackage/geopackage.py 92 93 94 95 96 97 98 99 def drop_feature_table ( self , name : str ) -> None : \"\"\"Delete a layer (feature table) by name. :param name: Name of the layer. \"\"\" table = self . feature_tables . pop ( name ) table . drop_tables ()","title":"GeoPackage"},{"location":"library-geopackage/#reference","text":"","title":"Reference"},{"location":"library-geopackage/#geopackage","text":"","title":"GeoPackage"},{"location":"library-geopackage/#unweaver.geopackage.GeoPackage","text":"A Python interface to a GeoPackage, an SQLite-format OGC standard for geospatial vector data. Parameters: Name Type Description Default path str Path to a GeoPackage (ends with .gpkg). If the path does not exist, it will be created. None Source code in unweaver/geopackage/geopackage.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 class GeoPackage : \"\"\"A Python interface to a GeoPackage, an SQLite-format OGC standard for geospatial vector data. :param path: Path to a GeoPackage (ends with .gpkg). If the path does not exist, it will be created. \"\"\" VERSION = 0 EMPTY = 1 def __init__ ( self , path : str = None ): if path is None : # TODO: revisit this behavior. Creating a temporary file by default # may be undesirable. # Create a temporary path, get the name _ , path = tempfile . mkstemp ( suffix = \".gpkg\" ) self . path = str ( path ) # Delete the path to prepare for fresh db os . remove ( path ) else : self . path = path self . _setup_database () self . feature_tables = {} # Instantiate FeatureTables that already exist in the db with self . connect () as conn : query_result = conn . execute ( \"SELECT table_name, srs_id FROM gpkg_contents\" ) table_rows = list ( query_result ) for row in table_rows : table_name = row [ \"table_name\" ] with self . connect () as conn : geom_type_query = conn . execute ( \"\"\" SELECT geometry_type_name FROM gpkg_geometry_columns WHERE table_name = ? \"\"\" , ( table_name ,), ) geom_type = next ( geom_type_query )[ \"geometry_type_name\" ] enum_geom_type = getattr ( GeoPackageGeoms , geom_type ) self . feature_tables [ table_name ] = FeatureTable ( self , table_name , enum_geom_type , srid = row [ \"srs_id\" ] ) def add_feature_table ( self , name : str , geom_type : GeoPackageGeoms , srid : int = 4326 ) -> FeatureTable : \"\"\"Create a new layer (feature table) in the GeoPackage. :param name: Name of the new layer. :param geom_type: Geometry type of the new layer. :srid: SRID (projection). \"\"\" table = FeatureTable ( self , name , geom_type , srid = srid ) table . create_tables () self . feature_tables [ name ] = table return table def drop_feature_table ( self , name : str ) -> None : \"\"\"Delete a layer (feature table) by name. :param name: Name of the layer. \"\"\" table = self . feature_tables . pop ( name ) table . drop_tables () def _is_connected ( self ) -> bool : try : self . conn . cursor () return True except Exception : return False def _get_connection ( self ) -> None : if not self . _is_connected (): conn = sqlite3 . connect ( self . path , uri = True , isolation_level = None ) # Spatialite used for rtree-based functions (MinX, etc). Can # eventually replace or make configurable with other extensions. conn . load_extension ( \"mod_spatialite.so\" ) conn . row_factory = self . _dict_factory self . conn = conn @contextlib . contextmanager def connect ( self ) -> Generator [ sqlite3 . Connection , None , None ]: self . _get_connection () yield self . conn def _setup_database ( self ) -> None : if self . _is_empty_database (): self . _create_database () def _is_empty_database ( self ) -> bool : is_empty = True with self . connect () as conn : query_result = conn . execute ( \"SELECT name FROM sqlite_master WHERE type = 'table'\" ) try : next ( query_result ) is_empty = False except StopIteration : is_empty = True return is_empty def _create_database ( self ) -> None : with self . connect () as conn : # Set the format metadata conn . execute ( f \"PRAGMA application_id = { GPKG_APPLICATION_ID } \" ) conn . execute ( f \"PRAGMA user_version = { GPKG_USER_VERSION } \" ) # Create gpkg_contents table conn . execute ( \"\"\" CREATE TABLE IF NOT EXISTS gpkg_contents ( table_name TEXT, data_type TEXT NOT NULL, identifier TEXT UNIQUE, description TEXT DEFAULT '', last_change TIMESTAMP DEFAULT CURRENT_TIMESTAMP, min_x DOUBLE, min_y DOUBLE, max_x DOUBLE, max_y DOUBLE, srs_id INTEGER, PRIMARY KEY (table_name) ) \"\"\" ) # Create gpkg_extensions table conn . execute ( \"\"\" CREATE TABLE IF NOT EXISTS gpkg_extensions( table_name TEXT, column_name TEXT, extension_name TEXT NOT NULL, definition TEXT NOT NULL, scope TEXT NOT NULL, UNIQUE (table_name, column_name, extension_name) ) \"\"\" ) # Create gpkg_geometry_columns table conn . execute ( \"\"\" CREATE TABLE IF NOT EXISTS gpkg_geometry_columns( table_name TEXT UNIQUE NOT NULL, column_name TEXT NOT NULL, geometry_type_name TEXT NOT NULL, srs_id INTEGER NOT NULL, z TINYINT NOT NULL, m TINYINT NOT NULL, PRIMARY KEY (table_name, column_name) ) \"\"\" ) # Create gpkg_ogr_contents table conn . execute ( \"\"\" CREATE TABLE IF NOT EXISTS gpkg_ogr_contents( table_name TEXT NOT NULL, feature_count INTEGER DEFAULT NULL, PRIMARY KEY (table_name) ) \"\"\" ) # Create gpkg_spatial_ref_sys conn . execute ( \"\"\" CREATE TABLE IF NOT EXISTS gpkg_spatial_ref_sys( srs_name TEXT NOT NULL, srs_id INTEGER NOT NULL, organization TEXT NOT NULL, organization_coordsys_id INTEGER NOT NULL, definition TEXT NOT NULL, description TEXT, PRIMARY KEY (srs_id) ) \"\"\" ) def copy ( self , path : str ) -> GeoPackage : \"\"\"Copies the current GeoPackage to a new location and returns a new instance of a GeoPackage. A convenient way to create an in-memory GeoPackage, as path can be any SQLite-compatible connection string, including :memory:. :param path: Path to the new database. Any SQLite connection string can be used. \"\"\" # TODO: catch the \"memory\" string and ensure that it includes a name # and shared cache. Our strategy requires reconnecting to the db, # so it must persist in memory. new_conn = sqlite3 . connect ( path ) new_conn . enable_load_extension ( True ) # Spatialite used for rtree-based functions (MinX, etc). Can eventually # replace or make configurable with other extensions. new_conn . load_extension ( \"mod_spatialite.so\" ) with self . connect () as conn : # Set row_factory to none for iterdumping conn . row_factory = None # Copy over all tables but not indices for line in conn . iterdump (): # Skip all index creation - these should be recreated # afterwards if \"CREATE TABLE\" in line or \"INSERT INTO\" in line : # TODO: derive index names from metadata table instead if \"idx_\" in line : continue if \"rtree_\" in line : continue if \"COMMIT\" in line : continue new_conn . cursor () . executescript ( line ) # Copy over all indices for line in conn . iterdump (): # Recreate the indices if \"CREATE TABLE\" in line or \"INSERT INTO\" in line : if \"idx_\" in line : new_conn . cursor () . executescript ( line ) if \"COMMIT\" in line : continue # TODO: rtree strategy is different? Why? # for line in conn.iterdump(): # # Recreate the indices # if \"CREATE TABLE\" in line or \"INSERT INTO\" in line: # if \"rtree_\" in line: # new_conn.cursor().executescript(line) # if \"COMMIT\" in line: # continue conn . row_factory = self . _dict_factory new_db = GeoPackage ( path ) return new_db # TODO: Instead of 'Any', use Python types that can be deserialized from # sqlite @staticmethod def _dict_factory ( cursor : sqlite3 . Cursor , row : sqlite3 . Row ) -> Dict [ str , Any ]: return { col [ 0 ]: row [ idx ] for idx , col in enumerate ( cursor . description )}","title":"GeoPackage"},{"location":"library-geopackage/#unweaver.geopackage.geopackage.GeoPackage.add_feature_table","text":"Create a new layer (feature table) in the GeoPackage. :srid: SRID (projection). Parameters: Name Type Description Default name str Name of the new layer. required geom_type GeoPackageGeoms Geometry type of the new layer. required Source code in unweaver/geopackage/geopackage.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def add_feature_table ( self , name : str , geom_type : GeoPackageGeoms , srid : int = 4326 ) -> FeatureTable : \"\"\"Create a new layer (feature table) in the GeoPackage. :param name: Name of the new layer. :param geom_type: Geometry type of the new layer. :srid: SRID (projection). \"\"\" table = FeatureTable ( self , name , geom_type , srid = srid ) table . create_tables () self . feature_tables [ name ] = table return table","title":"add_feature_table()"},{"location":"library-geopackage/#unweaver.geopackage.geopackage.GeoPackage.copy","text":"Copies the current GeoPackage to a new location and returns a new instance of a GeoPackage. A convenient way to create an in-memory GeoPackage, as path can be any SQLite-compatible connection string, including :memory:. Parameters: Name Type Description Default path str Path to the new database. Any SQLite connection string can be used. required Source code in unweaver/geopackage/geopackage.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def copy ( self , path : str ) -> GeoPackage : \"\"\"Copies the current GeoPackage to a new location and returns a new instance of a GeoPackage. A convenient way to create an in-memory GeoPackage, as path can be any SQLite-compatible connection string, including :memory:. :param path: Path to the new database. Any SQLite connection string can be used. \"\"\" # TODO: catch the \"memory\" string and ensure that it includes a name # and shared cache. Our strategy requires reconnecting to the db, # so it must persist in memory. new_conn = sqlite3 . connect ( path ) new_conn . enable_load_extension ( True ) # Spatialite used for rtree-based functions (MinX, etc). Can eventually # replace or make configurable with other extensions. new_conn . load_extension ( \"mod_spatialite.so\" ) with self . connect () as conn : # Set row_factory to none for iterdumping conn . row_factory = None # Copy over all tables but not indices for line in conn . iterdump (): # Skip all index creation - these should be recreated # afterwards if \"CREATE TABLE\" in line or \"INSERT INTO\" in line : # TODO: derive index names from metadata table instead if \"idx_\" in line : continue if \"rtree_\" in line : continue if \"COMMIT\" in line : continue new_conn . cursor () . executescript ( line ) # Copy over all indices for line in conn . iterdump (): # Recreate the indices if \"CREATE TABLE\" in line or \"INSERT INTO\" in line : if \"idx_\" in line : new_conn . cursor () . executescript ( line ) if \"COMMIT\" in line : continue # TODO: rtree strategy is different? Why? # for line in conn.iterdump(): # # Recreate the indices # if \"CREATE TABLE\" in line or \"INSERT INTO\" in line: # if \"rtree_\" in line: # new_conn.cursor().executescript(line) # if \"COMMIT\" in line: # continue conn . row_factory = self . _dict_factory new_db = GeoPackage ( path ) return new_db","title":"copy()"},{"location":"library-geopackage/#unweaver.geopackage.geopackage.GeoPackage.drop_feature_table","text":"Delete a layer (feature table) by name. Parameters: Name Type Description Default name str Name of the layer. required Source code in unweaver/geopackage/geopackage.py 92 93 94 95 96 97 98 99 def drop_feature_table ( self , name : str ) -> None : \"\"\"Delete a layer (feature table) by name. :param name: Name of the layer. \"\"\" table = self . feature_tables . pop ( name ) table . drop_tables ()","title":"drop_feature_table()"},{"location":"library-graphs/","text":"Reference Graphs unweaver.graphs.DiGraphGPKG Bases: DiGraphGPKGView Mutable directed graph backed by a GeoPackage. An extension of unweaver.graphs.DiGraphGPKGView. Parameters: Name Type Description Default path Optional [ str ] An optional path to database file (or :memory:-type string). None network Optional [ GeoPackageNetwork ] An optional path to a custom GeoPackageNetwork instance. None **kwargs Any Keyword arguments compatible with networkx.DiGraph. {} Source code in unweaver/graphs/digraphgpkg/digraphgpkg.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 class DiGraphGPKG ( DiGraphGPKGView ): \"\"\"Mutable directed graph backed by a GeoPackage. An extension of unweaver.graphs.DiGraphGPKGView. :param path: An optional path to database file (or :memory:-type string). :param network: An optional path to a custom GeoPackageNetwork instance. :param **kwargs: Keyword arguments compatible with networkx.DiGraph. \"\"\" node_dict_factory = Nodes adjlist_outer_dict_factory = OuterSuccessors # TODO: consider creating a read-only Mapping in the case of immutable # graphs. adjlist_inner_dict_factory = dict edge_attr_dict_factory = Edge def __init__ ( self , path : Optional [ str ] = None , network : Optional [ GeoPackageNetwork ] = None , ** kwargs : Any ): # TODO: Consider adding database file existence checker rather than # always checking on initialization? if network is None : # FIXME: should path be allowed to be None? if path is None : raise UnderspecifiedGraphError () else : if not os . path . exists ( path ): raise UnderspecifiedGraphError ( \"DB file does not exist. Consider using \" \"DiGraphGPKG.create_graph\" ) network = GeoPackageNetwork ( path ) super () . __init__ ( path = path , network = network , ** kwargs ) self . mutable = True @classmethod def create_graph ( cls , path : str = None , ** kwargs : Any ) -> DiGraphGPKG : \"\"\"Create a new DiGraphGPKG (.gpkg) at a given path. :param path: The path of the new GeoPackage (.gpkg). :param **kwargs: Any other keyword arguments to pass to the new DiGraphGPKG instance. :returns: A new DiGraphGPKG instance. \"\"\" network = GeoPackageNetwork ( path ) return DiGraphGPKG ( network = network , ** kwargs ) def add_edges_from ( self , ebunch : Iterable [ EdgeTuple ], _batch_size : int = 1000 , counter : Optional [ ProgressBar ] = None , ** attr : Any ) -> None : \"\"\"Equivalent to add_edges_from in networkx but with batched SQL writes. :param ebunch: edge bunch, identical to nx ebunch_to_add. :param _batch_size: Number of rows to commit to the database at a time. :param **attr: Default attributes, identical to nx attr. \"\"\" if _batch_size < 2 : # User has entered invalid number (negative, zero) or 1. Use # default behavior. super () . add_edges_from ( self , ebunch , ** attr ) return # TODO: length check on each edge features = ( { \"_u\" : edge [ 0 ], \"_v\" : edge [ 1 ], ** edge [ 2 ]} for edge in ebunch ) self . network . edges . write_features ( features , batch_size = _batch_size , counter = counter ) def update_edges ( self , ebunch : Iterable [ EdgeTuple ]) -> None : \"\"\"Update edges as a batch. :param ebunch: Any iterable of edge tuples (u, v, d). \"\"\" # FIXME: this doesn't actually work. Implement update / upsert # logic for GeoPackage feature tables, then use that. self . network . edges . update_edges ( ebunch ) add_edges_from ( ebunch , _batch_size = 1000 , counter = None , ** attr ) Equivalent to add_edges_from in networkx but with batched SQL writes. Parameters: Name Type Description Default ebunch Iterable [ EdgeTuple ] edge bunch, identical to nx ebunch_to_add. required _batch_size int Number of rows to commit to the database at a time. 1000 **attr Any Default attributes, identical to nx attr. {} Source code in unweaver/graphs/digraphgpkg/digraphgpkg.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def add_edges_from ( self , ebunch : Iterable [ EdgeTuple ], _batch_size : int = 1000 , counter : Optional [ ProgressBar ] = None , ** attr : Any ) -> None : \"\"\"Equivalent to add_edges_from in networkx but with batched SQL writes. :param ebunch: edge bunch, identical to nx ebunch_to_add. :param _batch_size: Number of rows to commit to the database at a time. :param **attr: Default attributes, identical to nx attr. \"\"\" if _batch_size < 2 : # User has entered invalid number (negative, zero) or 1. Use # default behavior. super () . add_edges_from ( self , ebunch , ** attr ) return # TODO: length check on each edge features = ( { \"_u\" : edge [ 0 ], \"_v\" : edge [ 1 ], ** edge [ 2 ]} for edge in ebunch ) self . network . edges . write_features ( features , batch_size = _batch_size , counter = counter ) create_graph ( path = None , ** kwargs ) classmethod Create a new DiGraphGPKG (.gpkg) at a given path. Parameters: Name Type Description Default path str The path of the new GeoPackage (.gpkg). None **kwargs Any Any other keyword arguments to pass to the new DiGraphGPKG instance. {} Returns: Type Description DiGraphGPKG A new DiGraphGPKG instance. Source code in unweaver/graphs/digraphgpkg/digraphgpkg.py 60 61 62 63 64 65 66 67 68 69 70 71 @classmethod def create_graph ( cls , path : str = None , ** kwargs : Any ) -> DiGraphGPKG : \"\"\"Create a new DiGraphGPKG (.gpkg) at a given path. :param path: The path of the new GeoPackage (.gpkg). :param **kwargs: Any other keyword arguments to pass to the new DiGraphGPKG instance. :returns: A new DiGraphGPKG instance. \"\"\" network = GeoPackageNetwork ( path ) return DiGraphGPKG ( network = network , ** kwargs ) update_edges ( ebunch ) Update edges as a batch. Parameters: Name Type Description Default ebunch Iterable [ EdgeTuple ] Any iterable of edge tuples (u, v, d). required Source code in unweaver/graphs/digraphgpkg/digraphgpkg.py 101 102 103 104 105 106 107 108 109 def update_edges ( self , ebunch : Iterable [ EdgeTuple ]) -> None : \"\"\"Update edges as a batch. :param ebunch: Any iterable of edge tuples (u, v, d). \"\"\" # FIXME: this doesn't actually work. Implement update / upsert # logic for GeoPackage feature tables, then use that. self . network . edges . update_edges ( ebunch ) unweaver.graphs.DiGraphGPKGView Bases: nx . DiGraph An immutable, networkx -compatible directed graph view over a routable GeoPackage. Either the path to a .gpkg file or an existing instance of unweaver.network_adapters.geopackagenetwork.GeoPackageNetwork must be provided. Parameters: Name Type Description Default incoming_graph_data Optional [ nx . DiGraph ] Any class derived from networkx.DiGraph . None path Optional [ str ] A path to the GeoPackage file (.gpkg). If no file exists at this path, one will be created. None network Optional [ GeoPackageNetwork ] An existing GeoPackageNetwork instance. None **attr Any Any parameters to be attached as graph attributes. {} Source code in unweaver/graphs/digraphgpkg/digraphgpkg_view.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 class DiGraphGPKGView ( nx . DiGraph ): \"\"\"An immutable, `networkx`-compatible directed graph view over a routable GeoPackage. Either the path to a .gpkg file or an existing instance of unweaver.network_adapters.geopackagenetwork.GeoPackageNetwork must be provided. :param incoming_graph_data: Any class derived from `networkx.DiGraph`. :param path: A path to the GeoPackage file (.gpkg). If no file exists at this path, one will be created. :param network: An existing GeoPackageNetwork instance. :param **attr: Any parameters to be attached as graph attributes. \"\"\" node_dict_factory = NodesView adjlist_outer_dict_factory = OuterSuccessorsView # In networkx, inner adjlist is only ever invoked without parameters in # order to assign new nodes or edges with no attr. Therefore, its # functionality can be accounted for elsewhere: via __getitem__ and # __setitem__ on the outer adjacency list. adjlist_inner_dict_factory = dict edge_attr_dict_factory = EdgeView def __init__ ( self , incoming_graph_data : Optional [ nx . DiGraph ] = None , path : Optional [ str ] = None , network : Optional [ GeoPackageNetwork ] = None , ** attr : Any , ): # Path attr overrides sqlite attr if path : network = GeoPackageNetwork ( path ) elif network is None : raise ValueError ( \"Path or network must be set\" ) self . network = network # The factories of nx dict-likes need to be informed of the connection self . adjlist_inner_dict_factory = self . adjlist_inner_dict_factory # FIXME: should use a persistent table/container for .graph as well. self . graph = {} self . _node = self . node_dict_factory ( self . network ) self . _succ = self . _adj = self . adjlist_outer_dict_factory ( self . network ) self . _pred = OuterPredecessorsView ( self . network ) if incoming_graph_data is not None : nx . convert . to_networkx_graph ( incoming_graph_data , create_using = self ) self . graph . update ( attr ) # Set custom flag for read-only graph DBs self . mutable = False def size ( self , weight : Optional [ str ] = None ) -> int : \"\"\"The 'size' of the directed graph, with the same behavior as `networkx.DiGraph`: if the weight parameter is set to a string, it's the sum of values for all edges that have that string as a key in their data dictionaries. If the weight parameter is unset, then it's the count of edges. :param weight: The string to use as an edge dictionary key to calculate a weighted sum over all edges. :returns: Either the number of edges (weight=None) or the sum of edge properties for the weight string. \"\"\" if weight is None : return len ( self . network . edges ) else : return super () . size ( weight = weight ) def iter_edges ( self ) -> Iterable [ EdgeTuple ]: \"\"\"Roughly equivalent to the .edges interface, but much faster. :returns: generator of (u, v, d) similar to .edges, but where d is a dictionary, not an Edge that syncs to database. \"\"\" # FIXME: handle case where initializing with ddict data from query. # If implemented here (adding **d to the edge factory arguments), it # will always attempt to update the database on a per-read basis! return ( ( u , v , dict ( self . edge_attr_dict_factory ( self . network , u , v ))) for u , v , d in self . network . edges . iter_edges () ) def edges_dwithin ( self , lon : float , lat : float , distance : float , sort : bool = False ) -> Iterable [ EdgeTuple ]: \"\"\"Retrieve an iterable of edges within N meters of a latitude-longitude coordinate pair. :param lon: Longitude of the query point. :param lat: Latitude of the query point. :param distance: Search radius for the edge, can be thought of as defining the circle radius with which edges will be tested for intersection. Is in meters. :param sort: Whether to sort the iterable by distance such that the nearest edges are iterated over first. :returns: A generator of edge tuples, possibly sorted by distance (if the `sort` argument is set to True). \"\"\" # TODO: document self.network.edges instead? return self . network . edges . dwithin_edges ( lon , lat , distance , sort = sort ) def to_in_memory ( self ) -> DiGraphGPKGView : \"\"\"Copy the GeoPackage, itself an SQLite database, into an in-memory SQLite database. This may speed up queries and is useful if you want to create an ephemeral graph. :returns: A new instance of this class, backed by an in-memory SQLite database. \"\"\" # TODO: make into 'copy' method instead, taking path as a parameter? db_id = uuid . uuid4 () path = f \"file:unweaver- { db_id } ?mode=memory&cache=shared\" new_network = self . network . copy ( path ) return self . __class__ ( network = new_network ) edges_dwithin ( lon , lat , distance , sort = False ) Retrieve an iterable of edges within N meters of a latitude-longitude coordinate pair. Parameters: Name Type Description Default lon float Longitude of the query point. required lat float Latitude of the query point. required distance float Search radius for the edge, can be thought of as defining the circle radius with which edges will be tested for intersection. Is in meters. required sort bool Whether to sort the iterable by distance such that the nearest edges are iterated over first. False Returns: Type Description Iterable [ EdgeTuple ] A generator of edge tuples, possibly sorted by distance (if the sort argument is set to True). Source code in unweaver/graphs/digraphgpkg/digraphgpkg_view.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def edges_dwithin ( self , lon : float , lat : float , distance : float , sort : bool = False ) -> Iterable [ EdgeTuple ]: \"\"\"Retrieve an iterable of edges within N meters of a latitude-longitude coordinate pair. :param lon: Longitude of the query point. :param lat: Latitude of the query point. :param distance: Search radius for the edge, can be thought of as defining the circle radius with which edges will be tested for intersection. Is in meters. :param sort: Whether to sort the iterable by distance such that the nearest edges are iterated over first. :returns: A generator of edge tuples, possibly sorted by distance (if the `sort` argument is set to True). \"\"\" # TODO: document self.network.edges instead? return self . network . edges . dwithin_edges ( lon , lat , distance , sort = sort ) iter_edges () Roughly equivalent to the .edges interface, but much faster. Returns: Type Description Iterable [ EdgeTuple ] generator of (u, v, d) similar to .edges, but where d is a dictionary, not an Edge that syncs to database. Source code in unweaver/graphs/digraphgpkg/digraphgpkg_view.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def iter_edges ( self ) -> Iterable [ EdgeTuple ]: \"\"\"Roughly equivalent to the .edges interface, but much faster. :returns: generator of (u, v, d) similar to .edges, but where d is a dictionary, not an Edge that syncs to database. \"\"\" # FIXME: handle case where initializing with ddict data from query. # If implemented here (adding **d to the edge factory arguments), it # will always attempt to update the database on a per-read basis! return ( ( u , v , dict ( self . edge_attr_dict_factory ( self . network , u , v ))) for u , v , d in self . network . edges . iter_edges () ) size ( weight = None ) The 'size' of the directed graph, with the same behavior as networkx.DiGraph : if the weight parameter is set to a string, it's the sum of values for all edges that have that string as a key in their data dictionaries. If the weight parameter is unset, then it's the count of edges. Parameters: Name Type Description Default weight Optional [ str ] The string to use as an edge dictionary key to calculate a weighted sum over all edges. None Returns: Type Description int Either the number of edges (weight=None) or the sum of edge properties for the weight string. Source code in unweaver/graphs/digraphgpkg/digraphgpkg_view.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def size ( self , weight : Optional [ str ] = None ) -> int : \"\"\"The 'size' of the directed graph, with the same behavior as `networkx.DiGraph`: if the weight parameter is set to a string, it's the sum of values for all edges that have that string as a key in their data dictionaries. If the weight parameter is unset, then it's the count of edges. :param weight: The string to use as an edge dictionary key to calculate a weighted sum over all edges. :returns: Either the number of edges (weight=None) or the sum of edge properties for the weight string. \"\"\" if weight is None : return len ( self . network . edges ) else : return super () . size ( weight = weight ) to_in_memory () Copy the GeoPackage, itself an SQLite database, into an in-memory SQLite database. This may speed up queries and is useful if you want to create an ephemeral graph. Returns: Type Description DiGraphGPKGView A new instance of this class, backed by an in-memory SQLite database. Source code in unweaver/graphs/digraphgpkg/digraphgpkg_view.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def to_in_memory ( self ) -> DiGraphGPKGView : \"\"\"Copy the GeoPackage, itself an SQLite database, into an in-memory SQLite database. This may speed up queries and is useful if you want to create an ephemeral graph. :returns: A new instance of this class, backed by an in-memory SQLite database. \"\"\" # TODO: make into 'copy' method instead, taking path as a parameter? db_id = uuid . uuid4 () path = f \"file:unweaver- { db_id } ?mode=memory&cache=shared\" new_network = self . network . copy ( path ) return self . __class__ ( network = new_network ) unweaver.graphs.AugmentedDiGraphGPKGView Bases: nx . DiGraph A wrapper over DiGraphGPKGView that allows for overlaying an in-memory DiGraph but with a seamless interface. When querying the graph, such as asking for a particular edge based on a (u, d) pair (G u ), an AugmentedDiGraphGPKGView will first attempt to retrieve this edge from the in-memory DiGraph, then check the DiGraphGPKGView. This wrapper is particularly useful for adding temporary nodes and edges for the purposes of running a graph analysis algorithm. For example, Unweaver uses AugmentedDiGraphGPKGView when it's necessary to start \"part-way along\" an edge for a shortest-path query using Dijkstra's algorithm. There is often no on-graph node near the physical locationfrom which someone wants to begin searching for shortest paths, so Unweaver creates two new temporary edges starting from the nearest point on the nearest edge, connecting them to the on-graph nodes for that edge, and creates an AugmentedDiGraphGPKGView using those temporary edges. Parameters: Name Type Description Default G DiGraphGPKGView A DiGraphGPKGView, usually the main graph data. required G_overlay nx . DiGraph A dict-of-dict-of-dicts (or networkx.DiGraph) to overlay. required Source code in unweaver/graphs/augmented.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 class AugmentedDiGraphGPKGView ( nx . DiGraph ): \"\"\"A wrapper over DiGraphGPKGView that allows for overlaying an in-memory DiGraph but with a seamless interface. When querying the graph, such as asking for a particular edge based on a (u, d) pair (G[u][v]), an AugmentedDiGraphGPKGView will first attempt to retrieve this edge from the in-memory DiGraph, then check the DiGraphGPKGView. This wrapper is particularly useful for adding temporary nodes and edges for the purposes of running a graph analysis algorithm. For example, Unweaver uses AugmentedDiGraphGPKGView when it's necessary to start \"part-way along\" an edge for a shortest-path query using Dijkstra's algorithm. There is often no on-graph node near the physical locationfrom which someone wants to begin searching for shortest paths, so Unweaver creates two new temporary edges starting from the nearest point on the nearest edge, connecting them to the on-graph nodes for that edge, and creates an AugmentedDiGraphGPKGView using those temporary edges. :param G: A DiGraphGPKGView, usually the main graph data. :param G_overlay: A dict-of-dict-of-dicts (or networkx.DiGraph) to overlay. \"\"\" node_dict_factory : Callable = AugmentedNodesView adjlist_outer_dict_factory : Callable = AugmentedOuterSuccessorsView # In networkx, inner adjlist is only ever invoked without parameters in # order to assign new nodes or edges with no attr. Therefore, its # functionality can be accounted for elsewhere: via __getitem__ and # __setitem__ on the outer adjacency list. adjlist_inner_dict_factory = dict edge_attr_dict_factory : Callable = dict def __init__ ( self , G : DiGraphGPKGView , G_overlay : nx . DiGraph ): # The factories of nx dict-likes need to be informed of the connection setattr ( self , \"node_dict_factory\" , partial ( self . node_dict_factory , _G = G , _G_overlay = G_overlay ), ) setattr ( self , \"adjlist_outer_dict_factory\" , partial ( self . adjlist_outer_dict_factory , _G = G , _G_overlay = G_overlay ), ) # Not 'partial' on this? setattr ( self , \"adjlist_inner_dict_factory\" , self . adjlist_inner_dict_factory ) setattr ( self , \"edge_attr_dict_factory\" , partial ( self . edge_attr_dict_factory , _G = G , _G_overlay = G_overlay ), ) self . graph : Dict [ Any , Any ] = {} setattr ( self , \"_node\" , self . node_dict_factory ()) self . _succ = self . _adj = self . adjlist_outer_dict_factory () self . _pred = AugmentedOuterPredecessorsView ( _G = G , _G_overlay = G_overlay ) self . network = G . network @classmethod def prepare_augmented ( cls : Type [ T ], G : DiGraphGPKGView , candidate : ProjectedNode ) -> T : \"\"\"Create an AugmentedDiGraphGPKGView based on a DiGraphGPKGView and a start point candidatee (a ProjectedNode class instance). This will embed an overlay node and two edges. :param G: The base DiGraphGPKGView. :param candidate: The potential start point candidate. \"\"\" temp_edges = [] if candidate . edges_in : for e in candidate . edges_in : temp_edges . append ( e ) if candidate . edges_out : for e in candidate . edges_out : temp_edges . append ( e ) G_overlay = nx . DiGraph () if temp_edges : G_overlay . add_edges_from ( temp_edges ) for u , v , d in temp_edges : # TODO: 'add_edges_from' should automatically add geometry info # to nodes. This is a workaround for the fact that it doesn't. G_overlay . nodes [ u ][ G . network . nodes . geom_column ] = Point ( d [ G . network . edges . geom_column ][ \"coordinates\" ][ 0 ] ) G_overlay . nodes [ v ][ G . network . nodes . geom_column ] = Point ( d [ G . network . edges . geom_column ][ \"coordinates\" ][ - 1 ] ) G_augmented = AugmentedDiGraphGPKGView ( G = G , G_overlay = G_overlay ) return G_augmented prepare_augmented ( G , candidate ) classmethod Create an AugmentedDiGraphGPKGView based on a DiGraphGPKGView and a start point candidatee (a ProjectedNode class instance). This will embed an overlay node and two edges. Parameters: Name Type Description Default G DiGraphGPKGView The base DiGraphGPKGView. required candidate ProjectedNode The potential start point candidate. required Source code in unweaver/graphs/augmented.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 @classmethod def prepare_augmented ( cls : Type [ T ], G : DiGraphGPKGView , candidate : ProjectedNode ) -> T : \"\"\"Create an AugmentedDiGraphGPKGView based on a DiGraphGPKGView and a start point candidatee (a ProjectedNode class instance). This will embed an overlay node and two edges. :param G: The base DiGraphGPKGView. :param candidate: The potential start point candidate. \"\"\" temp_edges = [] if candidate . edges_in : for e in candidate . edges_in : temp_edges . append ( e ) if candidate . edges_out : for e in candidate . edges_out : temp_edges . append ( e ) G_overlay = nx . DiGraph () if temp_edges : G_overlay . add_edges_from ( temp_edges ) for u , v , d in temp_edges : # TODO: 'add_edges_from' should automatically add geometry info # to nodes. This is a workaround for the fact that it doesn't. G_overlay . nodes [ u ][ G . network . nodes . geom_column ] = Point ( d [ G . network . edges . geom_column ][ \"coordinates\" ][ 0 ] ) G_overlay . nodes [ v ][ G . network . nodes . geom_column ] = Point ( d [ G . network . edges . geom_column ][ \"coordinates\" ][ - 1 ] ) G_augmented = AugmentedDiGraphGPKGView ( G = G , G_overlay = G_overlay ) return G_augmented","title":"Graphs"},{"location":"library-graphs/#reference","text":"","title":"Reference"},{"location":"library-graphs/#graphs","text":"","title":"Graphs"},{"location":"library-graphs/#unweaver.graphs.DiGraphGPKG","text":"Bases: DiGraphGPKGView Mutable directed graph backed by a GeoPackage. An extension of unweaver.graphs.DiGraphGPKGView. Parameters: Name Type Description Default path Optional [ str ] An optional path to database file (or :memory:-type string). None network Optional [ GeoPackageNetwork ] An optional path to a custom GeoPackageNetwork instance. None **kwargs Any Keyword arguments compatible with networkx.DiGraph. {} Source code in unweaver/graphs/digraphgpkg/digraphgpkg.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 class DiGraphGPKG ( DiGraphGPKGView ): \"\"\"Mutable directed graph backed by a GeoPackage. An extension of unweaver.graphs.DiGraphGPKGView. :param path: An optional path to database file (or :memory:-type string). :param network: An optional path to a custom GeoPackageNetwork instance. :param **kwargs: Keyword arguments compatible with networkx.DiGraph. \"\"\" node_dict_factory = Nodes adjlist_outer_dict_factory = OuterSuccessors # TODO: consider creating a read-only Mapping in the case of immutable # graphs. adjlist_inner_dict_factory = dict edge_attr_dict_factory = Edge def __init__ ( self , path : Optional [ str ] = None , network : Optional [ GeoPackageNetwork ] = None , ** kwargs : Any ): # TODO: Consider adding database file existence checker rather than # always checking on initialization? if network is None : # FIXME: should path be allowed to be None? if path is None : raise UnderspecifiedGraphError () else : if not os . path . exists ( path ): raise UnderspecifiedGraphError ( \"DB file does not exist. Consider using \" \"DiGraphGPKG.create_graph\" ) network = GeoPackageNetwork ( path ) super () . __init__ ( path = path , network = network , ** kwargs ) self . mutable = True @classmethod def create_graph ( cls , path : str = None , ** kwargs : Any ) -> DiGraphGPKG : \"\"\"Create a new DiGraphGPKG (.gpkg) at a given path. :param path: The path of the new GeoPackage (.gpkg). :param **kwargs: Any other keyword arguments to pass to the new DiGraphGPKG instance. :returns: A new DiGraphGPKG instance. \"\"\" network = GeoPackageNetwork ( path ) return DiGraphGPKG ( network = network , ** kwargs ) def add_edges_from ( self , ebunch : Iterable [ EdgeTuple ], _batch_size : int = 1000 , counter : Optional [ ProgressBar ] = None , ** attr : Any ) -> None : \"\"\"Equivalent to add_edges_from in networkx but with batched SQL writes. :param ebunch: edge bunch, identical to nx ebunch_to_add. :param _batch_size: Number of rows to commit to the database at a time. :param **attr: Default attributes, identical to nx attr. \"\"\" if _batch_size < 2 : # User has entered invalid number (negative, zero) or 1. Use # default behavior. super () . add_edges_from ( self , ebunch , ** attr ) return # TODO: length check on each edge features = ( { \"_u\" : edge [ 0 ], \"_v\" : edge [ 1 ], ** edge [ 2 ]} for edge in ebunch ) self . network . edges . write_features ( features , batch_size = _batch_size , counter = counter ) def update_edges ( self , ebunch : Iterable [ EdgeTuple ]) -> None : \"\"\"Update edges as a batch. :param ebunch: Any iterable of edge tuples (u, v, d). \"\"\" # FIXME: this doesn't actually work. Implement update / upsert # logic for GeoPackage feature tables, then use that. self . network . edges . update_edges ( ebunch )","title":"DiGraphGPKG"},{"location":"library-graphs/#unweaver.graphs.digraphgpkg.digraphgpkg.DiGraphGPKG.add_edges_from","text":"Equivalent to add_edges_from in networkx but with batched SQL writes. Parameters: Name Type Description Default ebunch Iterable [ EdgeTuple ] edge bunch, identical to nx ebunch_to_add. required _batch_size int Number of rows to commit to the database at a time. 1000 **attr Any Default attributes, identical to nx attr. {} Source code in unweaver/graphs/digraphgpkg/digraphgpkg.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def add_edges_from ( self , ebunch : Iterable [ EdgeTuple ], _batch_size : int = 1000 , counter : Optional [ ProgressBar ] = None , ** attr : Any ) -> None : \"\"\"Equivalent to add_edges_from in networkx but with batched SQL writes. :param ebunch: edge bunch, identical to nx ebunch_to_add. :param _batch_size: Number of rows to commit to the database at a time. :param **attr: Default attributes, identical to nx attr. \"\"\" if _batch_size < 2 : # User has entered invalid number (negative, zero) or 1. Use # default behavior. super () . add_edges_from ( self , ebunch , ** attr ) return # TODO: length check on each edge features = ( { \"_u\" : edge [ 0 ], \"_v\" : edge [ 1 ], ** edge [ 2 ]} for edge in ebunch ) self . network . edges . write_features ( features , batch_size = _batch_size , counter = counter )","title":"add_edges_from()"},{"location":"library-graphs/#unweaver.graphs.digraphgpkg.digraphgpkg.DiGraphGPKG.create_graph","text":"Create a new DiGraphGPKG (.gpkg) at a given path. Parameters: Name Type Description Default path str The path of the new GeoPackage (.gpkg). None **kwargs Any Any other keyword arguments to pass to the new DiGraphGPKG instance. {} Returns: Type Description DiGraphGPKG A new DiGraphGPKG instance. Source code in unweaver/graphs/digraphgpkg/digraphgpkg.py 60 61 62 63 64 65 66 67 68 69 70 71 @classmethod def create_graph ( cls , path : str = None , ** kwargs : Any ) -> DiGraphGPKG : \"\"\"Create a new DiGraphGPKG (.gpkg) at a given path. :param path: The path of the new GeoPackage (.gpkg). :param **kwargs: Any other keyword arguments to pass to the new DiGraphGPKG instance. :returns: A new DiGraphGPKG instance. \"\"\" network = GeoPackageNetwork ( path ) return DiGraphGPKG ( network = network , ** kwargs )","title":"create_graph()"},{"location":"library-graphs/#unweaver.graphs.digraphgpkg.digraphgpkg.DiGraphGPKG.update_edges","text":"Update edges as a batch. Parameters: Name Type Description Default ebunch Iterable [ EdgeTuple ] Any iterable of edge tuples (u, v, d). required Source code in unweaver/graphs/digraphgpkg/digraphgpkg.py 101 102 103 104 105 106 107 108 109 def update_edges ( self , ebunch : Iterable [ EdgeTuple ]) -> None : \"\"\"Update edges as a batch. :param ebunch: Any iterable of edge tuples (u, v, d). \"\"\" # FIXME: this doesn't actually work. Implement update / upsert # logic for GeoPackage feature tables, then use that. self . network . edges . update_edges ( ebunch )","title":"update_edges()"},{"location":"library-graphs/#unweaver.graphs.DiGraphGPKGView","text":"Bases: nx . DiGraph An immutable, networkx -compatible directed graph view over a routable GeoPackage. Either the path to a .gpkg file or an existing instance of unweaver.network_adapters.geopackagenetwork.GeoPackageNetwork must be provided. Parameters: Name Type Description Default incoming_graph_data Optional [ nx . DiGraph ] Any class derived from networkx.DiGraph . None path Optional [ str ] A path to the GeoPackage file (.gpkg). If no file exists at this path, one will be created. None network Optional [ GeoPackageNetwork ] An existing GeoPackageNetwork instance. None **attr Any Any parameters to be attached as graph attributes. {} Source code in unweaver/graphs/digraphgpkg/digraphgpkg_view.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 class DiGraphGPKGView ( nx . DiGraph ): \"\"\"An immutable, `networkx`-compatible directed graph view over a routable GeoPackage. Either the path to a .gpkg file or an existing instance of unweaver.network_adapters.geopackagenetwork.GeoPackageNetwork must be provided. :param incoming_graph_data: Any class derived from `networkx.DiGraph`. :param path: A path to the GeoPackage file (.gpkg). If no file exists at this path, one will be created. :param network: An existing GeoPackageNetwork instance. :param **attr: Any parameters to be attached as graph attributes. \"\"\" node_dict_factory = NodesView adjlist_outer_dict_factory = OuterSuccessorsView # In networkx, inner adjlist is only ever invoked without parameters in # order to assign new nodes or edges with no attr. Therefore, its # functionality can be accounted for elsewhere: via __getitem__ and # __setitem__ on the outer adjacency list. adjlist_inner_dict_factory = dict edge_attr_dict_factory = EdgeView def __init__ ( self , incoming_graph_data : Optional [ nx . DiGraph ] = None , path : Optional [ str ] = None , network : Optional [ GeoPackageNetwork ] = None , ** attr : Any , ): # Path attr overrides sqlite attr if path : network = GeoPackageNetwork ( path ) elif network is None : raise ValueError ( \"Path or network must be set\" ) self . network = network # The factories of nx dict-likes need to be informed of the connection self . adjlist_inner_dict_factory = self . adjlist_inner_dict_factory # FIXME: should use a persistent table/container for .graph as well. self . graph = {} self . _node = self . node_dict_factory ( self . network ) self . _succ = self . _adj = self . adjlist_outer_dict_factory ( self . network ) self . _pred = OuterPredecessorsView ( self . network ) if incoming_graph_data is not None : nx . convert . to_networkx_graph ( incoming_graph_data , create_using = self ) self . graph . update ( attr ) # Set custom flag for read-only graph DBs self . mutable = False def size ( self , weight : Optional [ str ] = None ) -> int : \"\"\"The 'size' of the directed graph, with the same behavior as `networkx.DiGraph`: if the weight parameter is set to a string, it's the sum of values for all edges that have that string as a key in their data dictionaries. If the weight parameter is unset, then it's the count of edges. :param weight: The string to use as an edge dictionary key to calculate a weighted sum over all edges. :returns: Either the number of edges (weight=None) or the sum of edge properties for the weight string. \"\"\" if weight is None : return len ( self . network . edges ) else : return super () . size ( weight = weight ) def iter_edges ( self ) -> Iterable [ EdgeTuple ]: \"\"\"Roughly equivalent to the .edges interface, but much faster. :returns: generator of (u, v, d) similar to .edges, but where d is a dictionary, not an Edge that syncs to database. \"\"\" # FIXME: handle case where initializing with ddict data from query. # If implemented here (adding **d to the edge factory arguments), it # will always attempt to update the database on a per-read basis! return ( ( u , v , dict ( self . edge_attr_dict_factory ( self . network , u , v ))) for u , v , d in self . network . edges . iter_edges () ) def edges_dwithin ( self , lon : float , lat : float , distance : float , sort : bool = False ) -> Iterable [ EdgeTuple ]: \"\"\"Retrieve an iterable of edges within N meters of a latitude-longitude coordinate pair. :param lon: Longitude of the query point. :param lat: Latitude of the query point. :param distance: Search radius for the edge, can be thought of as defining the circle radius with which edges will be tested for intersection. Is in meters. :param sort: Whether to sort the iterable by distance such that the nearest edges are iterated over first. :returns: A generator of edge tuples, possibly sorted by distance (if the `sort` argument is set to True). \"\"\" # TODO: document self.network.edges instead? return self . network . edges . dwithin_edges ( lon , lat , distance , sort = sort ) def to_in_memory ( self ) -> DiGraphGPKGView : \"\"\"Copy the GeoPackage, itself an SQLite database, into an in-memory SQLite database. This may speed up queries and is useful if you want to create an ephemeral graph. :returns: A new instance of this class, backed by an in-memory SQLite database. \"\"\" # TODO: make into 'copy' method instead, taking path as a parameter? db_id = uuid . uuid4 () path = f \"file:unweaver- { db_id } ?mode=memory&cache=shared\" new_network = self . network . copy ( path ) return self . __class__ ( network = new_network )","title":"DiGraphGPKGView"},{"location":"library-graphs/#unweaver.graphs.digraphgpkg.digraphgpkg_view.DiGraphGPKGView.edges_dwithin","text":"Retrieve an iterable of edges within N meters of a latitude-longitude coordinate pair. Parameters: Name Type Description Default lon float Longitude of the query point. required lat float Latitude of the query point. required distance float Search radius for the edge, can be thought of as defining the circle radius with which edges will be tested for intersection. Is in meters. required sort bool Whether to sort the iterable by distance such that the nearest edges are iterated over first. False Returns: Type Description Iterable [ EdgeTuple ] A generator of edge tuples, possibly sorted by distance (if the sort argument is set to True). Source code in unweaver/graphs/digraphgpkg/digraphgpkg_view.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def edges_dwithin ( self , lon : float , lat : float , distance : float , sort : bool = False ) -> Iterable [ EdgeTuple ]: \"\"\"Retrieve an iterable of edges within N meters of a latitude-longitude coordinate pair. :param lon: Longitude of the query point. :param lat: Latitude of the query point. :param distance: Search radius for the edge, can be thought of as defining the circle radius with which edges will be tested for intersection. Is in meters. :param sort: Whether to sort the iterable by distance such that the nearest edges are iterated over first. :returns: A generator of edge tuples, possibly sorted by distance (if the `sort` argument is set to True). \"\"\" # TODO: document self.network.edges instead? return self . network . edges . dwithin_edges ( lon , lat , distance , sort = sort )","title":"edges_dwithin()"},{"location":"library-graphs/#unweaver.graphs.digraphgpkg.digraphgpkg_view.DiGraphGPKGView.iter_edges","text":"Roughly equivalent to the .edges interface, but much faster. Returns: Type Description Iterable [ EdgeTuple ] generator of (u, v, d) similar to .edges, but where d is a dictionary, not an Edge that syncs to database. Source code in unweaver/graphs/digraphgpkg/digraphgpkg_view.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def iter_edges ( self ) -> Iterable [ EdgeTuple ]: \"\"\"Roughly equivalent to the .edges interface, but much faster. :returns: generator of (u, v, d) similar to .edges, but where d is a dictionary, not an Edge that syncs to database. \"\"\" # FIXME: handle case where initializing with ddict data from query. # If implemented here (adding **d to the edge factory arguments), it # will always attempt to update the database on a per-read basis! return ( ( u , v , dict ( self . edge_attr_dict_factory ( self . network , u , v ))) for u , v , d in self . network . edges . iter_edges () )","title":"iter_edges()"},{"location":"library-graphs/#unweaver.graphs.digraphgpkg.digraphgpkg_view.DiGraphGPKGView.size","text":"The 'size' of the directed graph, with the same behavior as networkx.DiGraph : if the weight parameter is set to a string, it's the sum of values for all edges that have that string as a key in their data dictionaries. If the weight parameter is unset, then it's the count of edges. Parameters: Name Type Description Default weight Optional [ str ] The string to use as an edge dictionary key to calculate a weighted sum over all edges. None Returns: Type Description int Either the number of edges (weight=None) or the sum of edge properties for the weight string. Source code in unweaver/graphs/digraphgpkg/digraphgpkg_view.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def size ( self , weight : Optional [ str ] = None ) -> int : \"\"\"The 'size' of the directed graph, with the same behavior as `networkx.DiGraph`: if the weight parameter is set to a string, it's the sum of values for all edges that have that string as a key in their data dictionaries. If the weight parameter is unset, then it's the count of edges. :param weight: The string to use as an edge dictionary key to calculate a weighted sum over all edges. :returns: Either the number of edges (weight=None) or the sum of edge properties for the weight string. \"\"\" if weight is None : return len ( self . network . edges ) else : return super () . size ( weight = weight )","title":"size()"},{"location":"library-graphs/#unweaver.graphs.digraphgpkg.digraphgpkg_view.DiGraphGPKGView.to_in_memory","text":"Copy the GeoPackage, itself an SQLite database, into an in-memory SQLite database. This may speed up queries and is useful if you want to create an ephemeral graph. Returns: Type Description DiGraphGPKGView A new instance of this class, backed by an in-memory SQLite database. Source code in unweaver/graphs/digraphgpkg/digraphgpkg_view.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def to_in_memory ( self ) -> DiGraphGPKGView : \"\"\"Copy the GeoPackage, itself an SQLite database, into an in-memory SQLite database. This may speed up queries and is useful if you want to create an ephemeral graph. :returns: A new instance of this class, backed by an in-memory SQLite database. \"\"\" # TODO: make into 'copy' method instead, taking path as a parameter? db_id = uuid . uuid4 () path = f \"file:unweaver- { db_id } ?mode=memory&cache=shared\" new_network = self . network . copy ( path ) return self . __class__ ( network = new_network )","title":"to_in_memory()"},{"location":"library-graphs/#unweaver.graphs.AugmentedDiGraphGPKGView","text":"Bases: nx . DiGraph A wrapper over DiGraphGPKGView that allows for overlaying an in-memory DiGraph but with a seamless interface. When querying the graph, such as asking for a particular edge based on a (u, d) pair (G u ), an AugmentedDiGraphGPKGView will first attempt to retrieve this edge from the in-memory DiGraph, then check the DiGraphGPKGView. This wrapper is particularly useful for adding temporary nodes and edges for the purposes of running a graph analysis algorithm. For example, Unweaver uses AugmentedDiGraphGPKGView when it's necessary to start \"part-way along\" an edge for a shortest-path query using Dijkstra's algorithm. There is often no on-graph node near the physical locationfrom which someone wants to begin searching for shortest paths, so Unweaver creates two new temporary edges starting from the nearest point on the nearest edge, connecting them to the on-graph nodes for that edge, and creates an AugmentedDiGraphGPKGView using those temporary edges. Parameters: Name Type Description Default G DiGraphGPKGView A DiGraphGPKGView, usually the main graph data. required G_overlay nx . DiGraph A dict-of-dict-of-dicts (or networkx.DiGraph) to overlay. required Source code in unweaver/graphs/augmented.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 class AugmentedDiGraphGPKGView ( nx . DiGraph ): \"\"\"A wrapper over DiGraphGPKGView that allows for overlaying an in-memory DiGraph but with a seamless interface. When querying the graph, such as asking for a particular edge based on a (u, d) pair (G[u][v]), an AugmentedDiGraphGPKGView will first attempt to retrieve this edge from the in-memory DiGraph, then check the DiGraphGPKGView. This wrapper is particularly useful for adding temporary nodes and edges for the purposes of running a graph analysis algorithm. For example, Unweaver uses AugmentedDiGraphGPKGView when it's necessary to start \"part-way along\" an edge for a shortest-path query using Dijkstra's algorithm. There is often no on-graph node near the physical locationfrom which someone wants to begin searching for shortest paths, so Unweaver creates two new temporary edges starting from the nearest point on the nearest edge, connecting them to the on-graph nodes for that edge, and creates an AugmentedDiGraphGPKGView using those temporary edges. :param G: A DiGraphGPKGView, usually the main graph data. :param G_overlay: A dict-of-dict-of-dicts (or networkx.DiGraph) to overlay. \"\"\" node_dict_factory : Callable = AugmentedNodesView adjlist_outer_dict_factory : Callable = AugmentedOuterSuccessorsView # In networkx, inner adjlist is only ever invoked without parameters in # order to assign new nodes or edges with no attr. Therefore, its # functionality can be accounted for elsewhere: via __getitem__ and # __setitem__ on the outer adjacency list. adjlist_inner_dict_factory = dict edge_attr_dict_factory : Callable = dict def __init__ ( self , G : DiGraphGPKGView , G_overlay : nx . DiGraph ): # The factories of nx dict-likes need to be informed of the connection setattr ( self , \"node_dict_factory\" , partial ( self . node_dict_factory , _G = G , _G_overlay = G_overlay ), ) setattr ( self , \"adjlist_outer_dict_factory\" , partial ( self . adjlist_outer_dict_factory , _G = G , _G_overlay = G_overlay ), ) # Not 'partial' on this? setattr ( self , \"adjlist_inner_dict_factory\" , self . adjlist_inner_dict_factory ) setattr ( self , \"edge_attr_dict_factory\" , partial ( self . edge_attr_dict_factory , _G = G , _G_overlay = G_overlay ), ) self . graph : Dict [ Any , Any ] = {} setattr ( self , \"_node\" , self . node_dict_factory ()) self . _succ = self . _adj = self . adjlist_outer_dict_factory () self . _pred = AugmentedOuterPredecessorsView ( _G = G , _G_overlay = G_overlay ) self . network = G . network @classmethod def prepare_augmented ( cls : Type [ T ], G : DiGraphGPKGView , candidate : ProjectedNode ) -> T : \"\"\"Create an AugmentedDiGraphGPKGView based on a DiGraphGPKGView and a start point candidatee (a ProjectedNode class instance). This will embed an overlay node and two edges. :param G: The base DiGraphGPKGView. :param candidate: The potential start point candidate. \"\"\" temp_edges = [] if candidate . edges_in : for e in candidate . edges_in : temp_edges . append ( e ) if candidate . edges_out : for e in candidate . edges_out : temp_edges . append ( e ) G_overlay = nx . DiGraph () if temp_edges : G_overlay . add_edges_from ( temp_edges ) for u , v , d in temp_edges : # TODO: 'add_edges_from' should automatically add geometry info # to nodes. This is a workaround for the fact that it doesn't. G_overlay . nodes [ u ][ G . network . nodes . geom_column ] = Point ( d [ G . network . edges . geom_column ][ \"coordinates\" ][ 0 ] ) G_overlay . nodes [ v ][ G . network . nodes . geom_column ] = Point ( d [ G . network . edges . geom_column ][ \"coordinates\" ][ - 1 ] ) G_augmented = AugmentedDiGraphGPKGView ( G = G , G_overlay = G_overlay ) return G_augmented","title":"AugmentedDiGraphGPKGView"},{"location":"library-graphs/#unweaver.graphs.augmented.AugmentedDiGraphGPKGView.prepare_augmented","text":"Create an AugmentedDiGraphGPKGView based on a DiGraphGPKGView and a start point candidatee (a ProjectedNode class instance). This will embed an overlay node and two edges. Parameters: Name Type Description Default G DiGraphGPKGView The base DiGraphGPKGView. required candidate ProjectedNode The potential start point candidate. required Source code in unweaver/graphs/augmented.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 @classmethod def prepare_augmented ( cls : Type [ T ], G : DiGraphGPKGView , candidate : ProjectedNode ) -> T : \"\"\"Create an AugmentedDiGraphGPKGView based on a DiGraphGPKGView and a start point candidatee (a ProjectedNode class instance). This will embed an overlay node and two edges. :param G: The base DiGraphGPKGView. :param candidate: The potential start point candidate. \"\"\" temp_edges = [] if candidate . edges_in : for e in candidate . edges_in : temp_edges . append ( e ) if candidate . edges_out : for e in candidate . edges_out : temp_edges . append ( e ) G_overlay = nx . DiGraph () if temp_edges : G_overlay . add_edges_from ( temp_edges ) for u , v , d in temp_edges : # TODO: 'add_edges_from' should automatically add geometry info # to nodes. This is a workaround for the fact that it doesn't. G_overlay . nodes [ u ][ G . network . nodes . geom_column ] = Point ( d [ G . network . edges . geom_column ][ \"coordinates\" ][ 0 ] ) G_overlay . nodes [ v ][ G . network . nodes . geom_column ] = Point ( d [ G . network . edges . geom_column ][ \"coordinates\" ][ - 1 ] ) G_augmented = AugmentedDiGraphGPKGView ( G = G , G_overlay = G_overlay ) return G_augmented","title":"prepare_augmented()"},{"location":"library-shortest-paths/","text":"Reference Shortest paths unweaver . shortest_paths . shortest_path . shortest_path ( G , origin_node , destination_node , cost_function ) Find the shortest path from one on-graph node to another. Parameters: Name Type Description Default G DiGraphGPKGView The graph to use for this shortest path search. required origin_node str The start node ID. required destination_node str The end node ID. required cost_function CostFunction A dynamic cost function. required precalculated_cost_function A cost function that finds a precalculated weight. required Source code in unweaver/shortest_paths/shortest_path.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def shortest_path ( G : DiGraphGPKGView , origin_node : str , destination_node : str , cost_function : CostFunction , ) -> Tuple [ float , List [ str ], List [ EdgeData ]]: \"\"\"Find the shortest path from one on-graph node to another. :param G: The graph to use for this shortest path search. :param origin_node: The start node ID. :param destination_node: The end node ID. :param cost_function: A dynamic cost function. :param precalculated_cost_function: A cost function that finds a precalculated weight. \"\"\" return shortest_path_multi ( G , [ origin_node , destination_node ], cost_function ) unweaver . shortest_paths . shortest_path . shortest_path_multi ( G , nodes , cost_function ) Find the on-graph shortest path between multiple waypoints (nodes). Parameters: Name Type Description Default G DiGraphGPKGView The routing graph. required nodes List [ Union [ str , ProjectedNode ]] A list of nodes to visit, finding the shortest path between each. required cost_function CostFunction A networkx-compatible cost function. Takes u, v, ddict as parameters and returns a single number. required Source code in unweaver/shortest_paths/shortest_path.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def shortest_path_multi ( G : DiGraphGPKGView , nodes : List [ Union [ str , ProjectedNode ]], cost_function : CostFunction , ) -> Tuple [ float , List [ str ], List [ EdgeData ]]: \"\"\"Find the on-graph shortest path between multiple waypoints (nodes). :param G: The routing graph. :param nodes: A list of nodes to visit, finding the shortest path between each. :param cost_function: A networkx-compatible cost function. Takes u, v, ddict as parameters and returns a single number. \"\"\" # FIXME: written in a way that expects all waypoint nodes to have been # pre-vetted to be non-None # TODO: Extract invertible/flippable edge attributes into the profile. # NOTE: Written this way to anticipate multi-waypoint routing G_overlay = nx . DiGraph () node_list = [] for node in nodes : if isinstance ( node , ProjectedNode ): if node . edges_out : G_overlay . add_edges_from ( node . edges_out ) if node . edges_in : G_overlay . add_edges_from ( node . edges_in ) node_list . append ( node . n ) else : node_list . append ( node ) pairs = zip ( node_list [: - 1 ], node_list [ 1 :]) G_aug = AugmentedDiGraphGPKGView ( G = G , G_overlay = G_overlay ) result_legs = [] cost : float path : List [ str ] edges : List [ Dict [ str , Any ]] for n1 , n2 in pairs : try : cost , path = multi_source_dijkstra ( G_aug , sources = [ n1 ], target = n2 , weight = cost_function ) except nx . exception . NetworkXNoPath : raise NoPathError ( \"No viable path found.\" ) if cost is None : raise NoPathError ( \"No viable path found.\" ) edges = [ dict ( G_aug [ u ][ v ]) for u , v in zip ( path , path [ 1 :])] result_legs . append (( cost , path , edges )) # TODO: Return multiple legs once multiple waypoints supported return result_legs [ 0 ] unweaver . shortest_paths . shortest_path_tree . shortest_path_tree ( G , start_node , cost_function , max_cost = None , precalculated_cost_function = None ) Find the shortest paths to on-graph nodes starting at a given edge/node, subject to a maximum total \"distance\"/cost constraint. Parameters: Name Type Description Default G Union [ AugmentedDiGraphGPKGView , DiGraphGPKGView ] Network graph. required start_node str Start node (on graph) at which to begin search. required cost_function CostFunction NetworkX-compatible weight function. required max_cost Optional [ float ] Maximum weight to reach in the tree. None precalculated_cost_function Optional [ CostFunction ] NetworkX-compatible weight function that represents precalculated weights. None Source code in unweaver/shortest_paths/shortest_path_tree.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def shortest_path_tree ( G : Union [ AugmentedDiGraphGPKGView , DiGraphGPKGView ], start_node : str , cost_function : CostFunction , max_cost : Optional [ float ] = None , precalculated_cost_function : Optional [ CostFunction ] = None , ) -> Tuple [ ReachedNodes , Paths , Iterable [ EdgeData ]]: \"\"\"Find the shortest paths to on-graph nodes starting at a given edge/node, subject to a maximum total \"distance\"/cost constraint. :param G: Network graph. :param start_node: Start node (on graph) at which to begin search. :param cost_function: NetworkX-compatible weight function. :param max_cost: Maximum weight to reach in the tree. :param precalculated_cost_function: NetworkX-compatible weight function that represents precalculated weights. \"\"\" if precalculated_cost_function is not None : cost_function = precalculated_cost_function paths : Paths distances , paths = single_source_dijkstra ( G , start_node , cutoff = max_cost , weight = cost_function ) # Extract unique edges edge_ids = list ( set ([( u , v ) for p in paths . values () for u , v in zip ( p , p [ 1 :])]) ) # FIXME: graph should leverage a 'get an nbunch' method so that this # requires only one SQL query. def edge_data_generator ( G : DiGraphGPKGView , edge_ids : List [ Tuple [ str , str ]] ) -> Iterable [ EdgeData ]: for u , v in edge_ids : edge = dict ( G [ u ][ v ]) edge [ \"_u\" ] = u edge [ \"_v\" ] = v yield edge edges_data = edge_data_generator ( G , edge_ids ) geom_key = G . network . nodes . geom_column # Create nodes dictionary that contains both cost data and node attributes nodes : ReachedNodes = {} for node_id , distance in distances . items (): node_attr = G . nodes [ node_id ] nodes [ node_id ] = ReachedNode ( key = node_id , geom = node_attr [ geom_key ], cost = distance ) return nodes , paths , edges_data unweaver . shortest_paths . reachable_tree . reachable_tree ( G , candidate , cost_function , max_cost , precalculated_cost_function = None ) Generate all reachable places on graph, allowing extensions beyond existing nodes (e.g., assuming cost function is distance in meters and max_cost is 400, will extend to 400 meters from origin, creating new fake nodes at the ends. Parameters: Name Type Description Default G Union [ AugmentedDiGraphGPKGView , DiGraphGPKGView ] Network graph. required candidate ProjectedNode On-graph candidate metadata as created by waypoint_candidates. required cost_function CostFunction NetworkX-compatible weight function. required max_cost float Maximum weight to reach in the tree. required precalculated_cost_function Optional [ CostFunction ] NetworkX-compatible weight function that represents precalculated weights. None Source code in unweaver/shortest_paths/reachable_tree.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def reachable_tree ( G : Union [ AugmentedDiGraphGPKGView , DiGraphGPKGView ], candidate : ProjectedNode , cost_function : CostFunction , max_cost : float , precalculated_cost_function : Optional [ CostFunction ] = None , ) -> Tuple [ Dict [ str , ReachedNode ], List [ EdgeData ]]: \"\"\"Generate all reachable places on graph, allowing extensions beyond existing nodes (e.g., assuming cost function is distance in meters and max_cost is 400, will extend to 400 meters from origin, creating new fake nodes at the ends. :param G: Network graph. :param candidate: On-graph candidate metadata as created by waypoint_candidates. :param cost_function: NetworkX-compatible weight function. :param max_cost: Maximum weight to reach in the tree. :param precalculated_cost_function: NetworkX-compatible weight function that represents precalculated weights. \"\"\" # TODO: reuse these edges - lookup of edges from graph is often slowest if precalculated_cost_function is None : nodes , paths , edges = shortest_path_tree ( G , candidate . n , cost_function , max_cost ) else : nodes , paths , edges = shortest_path_tree ( G , candidate . n , precalculated_cost_function , max_cost ) # The shortest-path tree already contains all on-graph nodes within # max_cost distance. The only edges we need to add to make it the full, # extended, 'reachable' graph are: # 1) Partial edges at the fringe: these extend a relatively short way # down a given edge and do not connect to any other partial edges. # 2) \"Internal\" edges that weren't counted originally because they don't # fall on a shortest path, but are still reachable. These edges must # connect nodes on the shortest-path tree - if one node wasn't on the # shortest-path tree and we need to include the whole edge, that edge # should've been on the shortest-path tree (proof to come). edges = list ( edges ) traveled_edges = set (( e [ \"_u\" ], e [ \"_v\" ]) for e in edges ) traveled_nodes = set ([ n for path in paths . values () for n in path ]) if G . is_directed (): neighbor_func = G . successors else : neighbor_func = G . neighbors fringe_candidates = {} for u in traveled_nodes : if u not in G : # For some reason, this only happens to the in-memory graph: the # \"pseudo\" node created in paths that start along an edge remains # and of course does not exist in the true graph. # Investigate: FIXME! continue for v in neighbor_func ( u ): # Ignore already-traveled edges if ( u , v ) in traveled_edges : continue traveled_edges . add (( u , v )) # Determine cost of traversal edge_data = G [ u ][ v ] edge_data = dict ( edge_data ) # FIXME: this value is incorrect for precalculated weights. Need # to maintain precalculated and non-precalculated versions of the # cost function and apply the non-precalculated for these # situations. cost = cost_function ( u , v , edge_data ) # Exclude non-traversible edges if cost is None : continue # If the total cost is still less than max_cost, we will have # traveled the whole edge - there is no new \"pseudo\" node, only a # new edge. if v in nodes and nodes [ v ] . cost + cost < max_cost : interpolate_proportion = 1.0 else : remaining = max_cost - nodes [ u ] . cost interpolate_proportion = remaining / cost # TODO: Use consistent data classes for passing around edge data, # leave (de)serialization concerns up to near-db interfaces edge_data [ \"_u\" ] = u edge_data [ \"_v\" ] = v fringe_candidate : FringeCandidate = { \"cost\" : cost , \"edge_data\" : edge_data , \"proportion\" : interpolate_proportion , } fringe_candidates [( u , v )] = fringe_candidate fringe_edges = [] seen = set () # Don't treat origin point edge as fringe-y: each start point in the # shortest-path tree was reachable from the initial half-edge. # started = list(set([path[0] for target, path in paths.items()])) # Adjust / remove fringe proportions based on context for edge_id , fringe_candidate in fringe_candidates . items (): # Skip already-seen edges (e.g. reverse edges we looked ahead for). if edge_id in seen : continue edge_data = fringe_candidate [ \"edge_data\" ] proportion = fringe_candidate [ \"proportion\" ] cost = fringe_candidate [ \"cost\" ] # Can traverse whole edge - keep it if proportion == 1 : fringe_edges . append ( edge_data ) continue rev_edge_id = ( edge_id [ 1 ], edge_id [ 0 ]) # reverse_intersected = False has_reverse = rev_edge_id in fringe_candidates if has_reverse : # This edge is \"internal\": it's being traversed from both sides rev_proportion = fringe_candidates [ rev_edge_id ][ \"proportion\" ] if proportion + rev_proportion > 1 : # They intersect - the entire edge can be traversed. fringe_edges . append ( edge_data ) continue else : # They do not intersect. Keep the original proportions pass # If this point has been reached, this is: # (1) A partial extension down an edge # (2) It doesn't overlap with any other partial edges # Create primary partial edge and node and append to the saved data fringe_edge , fringe_node = _make_partial_edge ( G , edge_data , proportion ) fringe_edges . append ( fringe_edge ) fringe_node_id = fringe_node . key nodes [ fringe_node_id ] = ReachedNode ( key = fringe_node . key , geom = fringe_node . geom , cost = max_cost ) seen . add ( edge_id ) edges = edges + fringe_edges for edge in edges : geom = edge [ \"geom\" ] if isinstance ( geom , LineString ): edge [ \"geom\" ] = asdict ( geom ) return nodes , edges","title":"Shortest paths"},{"location":"library-shortest-paths/#reference","text":"","title":"Reference"},{"location":"library-shortest-paths/#shortest-paths","text":"","title":"Shortest paths"},{"location":"library-shortest-paths/#unweaver.shortest_paths.shortest_path.shortest_path","text":"Find the shortest path from one on-graph node to another. Parameters: Name Type Description Default G DiGraphGPKGView The graph to use for this shortest path search. required origin_node str The start node ID. required destination_node str The end node ID. required cost_function CostFunction A dynamic cost function. required precalculated_cost_function A cost function that finds a precalculated weight. required Source code in unweaver/shortest_paths/shortest_path.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def shortest_path ( G : DiGraphGPKGView , origin_node : str , destination_node : str , cost_function : CostFunction , ) -> Tuple [ float , List [ str ], List [ EdgeData ]]: \"\"\"Find the shortest path from one on-graph node to another. :param G: The graph to use for this shortest path search. :param origin_node: The start node ID. :param destination_node: The end node ID. :param cost_function: A dynamic cost function. :param precalculated_cost_function: A cost function that finds a precalculated weight. \"\"\" return shortest_path_multi ( G , [ origin_node , destination_node ], cost_function )","title":"shortest_path()"},{"location":"library-shortest-paths/#unweaver.shortest_paths.shortest_path.shortest_path_multi","text":"Find the on-graph shortest path between multiple waypoints (nodes). Parameters: Name Type Description Default G DiGraphGPKGView The routing graph. required nodes List [ Union [ str , ProjectedNode ]] A list of nodes to visit, finding the shortest path between each. required cost_function CostFunction A networkx-compatible cost function. Takes u, v, ddict as parameters and returns a single number. required Source code in unweaver/shortest_paths/shortest_path.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def shortest_path_multi ( G : DiGraphGPKGView , nodes : List [ Union [ str , ProjectedNode ]], cost_function : CostFunction , ) -> Tuple [ float , List [ str ], List [ EdgeData ]]: \"\"\"Find the on-graph shortest path between multiple waypoints (nodes). :param G: The routing graph. :param nodes: A list of nodes to visit, finding the shortest path between each. :param cost_function: A networkx-compatible cost function. Takes u, v, ddict as parameters and returns a single number. \"\"\" # FIXME: written in a way that expects all waypoint nodes to have been # pre-vetted to be non-None # TODO: Extract invertible/flippable edge attributes into the profile. # NOTE: Written this way to anticipate multi-waypoint routing G_overlay = nx . DiGraph () node_list = [] for node in nodes : if isinstance ( node , ProjectedNode ): if node . edges_out : G_overlay . add_edges_from ( node . edges_out ) if node . edges_in : G_overlay . add_edges_from ( node . edges_in ) node_list . append ( node . n ) else : node_list . append ( node ) pairs = zip ( node_list [: - 1 ], node_list [ 1 :]) G_aug = AugmentedDiGraphGPKGView ( G = G , G_overlay = G_overlay ) result_legs = [] cost : float path : List [ str ] edges : List [ Dict [ str , Any ]] for n1 , n2 in pairs : try : cost , path = multi_source_dijkstra ( G_aug , sources = [ n1 ], target = n2 , weight = cost_function ) except nx . exception . NetworkXNoPath : raise NoPathError ( \"No viable path found.\" ) if cost is None : raise NoPathError ( \"No viable path found.\" ) edges = [ dict ( G_aug [ u ][ v ]) for u , v in zip ( path , path [ 1 :])] result_legs . append (( cost , path , edges )) # TODO: Return multiple legs once multiple waypoints supported return result_legs [ 0 ]","title":"shortest_path_multi()"},{"location":"library-shortest-paths/#unweaver.shortest_paths.shortest_path_tree.shortest_path_tree","text":"Find the shortest paths to on-graph nodes starting at a given edge/node, subject to a maximum total \"distance\"/cost constraint. Parameters: Name Type Description Default G Union [ AugmentedDiGraphGPKGView , DiGraphGPKGView ] Network graph. required start_node str Start node (on graph) at which to begin search. required cost_function CostFunction NetworkX-compatible weight function. required max_cost Optional [ float ] Maximum weight to reach in the tree. None precalculated_cost_function Optional [ CostFunction ] NetworkX-compatible weight function that represents precalculated weights. None Source code in unweaver/shortest_paths/shortest_path_tree.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def shortest_path_tree ( G : Union [ AugmentedDiGraphGPKGView , DiGraphGPKGView ], start_node : str , cost_function : CostFunction , max_cost : Optional [ float ] = None , precalculated_cost_function : Optional [ CostFunction ] = None , ) -> Tuple [ ReachedNodes , Paths , Iterable [ EdgeData ]]: \"\"\"Find the shortest paths to on-graph nodes starting at a given edge/node, subject to a maximum total \"distance\"/cost constraint. :param G: Network graph. :param start_node: Start node (on graph) at which to begin search. :param cost_function: NetworkX-compatible weight function. :param max_cost: Maximum weight to reach in the tree. :param precalculated_cost_function: NetworkX-compatible weight function that represents precalculated weights. \"\"\" if precalculated_cost_function is not None : cost_function = precalculated_cost_function paths : Paths distances , paths = single_source_dijkstra ( G , start_node , cutoff = max_cost , weight = cost_function ) # Extract unique edges edge_ids = list ( set ([( u , v ) for p in paths . values () for u , v in zip ( p , p [ 1 :])]) ) # FIXME: graph should leverage a 'get an nbunch' method so that this # requires only one SQL query. def edge_data_generator ( G : DiGraphGPKGView , edge_ids : List [ Tuple [ str , str ]] ) -> Iterable [ EdgeData ]: for u , v in edge_ids : edge = dict ( G [ u ][ v ]) edge [ \"_u\" ] = u edge [ \"_v\" ] = v yield edge edges_data = edge_data_generator ( G , edge_ids ) geom_key = G . network . nodes . geom_column # Create nodes dictionary that contains both cost data and node attributes nodes : ReachedNodes = {} for node_id , distance in distances . items (): node_attr = G . nodes [ node_id ] nodes [ node_id ] = ReachedNode ( key = node_id , geom = node_attr [ geom_key ], cost = distance ) return nodes , paths , edges_data","title":"shortest_path_tree()"},{"location":"library-shortest-paths/#unweaver.shortest_paths.reachable_tree.reachable_tree","text":"Generate all reachable places on graph, allowing extensions beyond existing nodes (e.g., assuming cost function is distance in meters and max_cost is 400, will extend to 400 meters from origin, creating new fake nodes at the ends. Parameters: Name Type Description Default G Union [ AugmentedDiGraphGPKGView , DiGraphGPKGView ] Network graph. required candidate ProjectedNode On-graph candidate metadata as created by waypoint_candidates. required cost_function CostFunction NetworkX-compatible weight function. required max_cost float Maximum weight to reach in the tree. required precalculated_cost_function Optional [ CostFunction ] NetworkX-compatible weight function that represents precalculated weights. None Source code in unweaver/shortest_paths/reachable_tree.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def reachable_tree ( G : Union [ AugmentedDiGraphGPKGView , DiGraphGPKGView ], candidate : ProjectedNode , cost_function : CostFunction , max_cost : float , precalculated_cost_function : Optional [ CostFunction ] = None , ) -> Tuple [ Dict [ str , ReachedNode ], List [ EdgeData ]]: \"\"\"Generate all reachable places on graph, allowing extensions beyond existing nodes (e.g., assuming cost function is distance in meters and max_cost is 400, will extend to 400 meters from origin, creating new fake nodes at the ends. :param G: Network graph. :param candidate: On-graph candidate metadata as created by waypoint_candidates. :param cost_function: NetworkX-compatible weight function. :param max_cost: Maximum weight to reach in the tree. :param precalculated_cost_function: NetworkX-compatible weight function that represents precalculated weights. \"\"\" # TODO: reuse these edges - lookup of edges from graph is often slowest if precalculated_cost_function is None : nodes , paths , edges = shortest_path_tree ( G , candidate . n , cost_function , max_cost ) else : nodes , paths , edges = shortest_path_tree ( G , candidate . n , precalculated_cost_function , max_cost ) # The shortest-path tree already contains all on-graph nodes within # max_cost distance. The only edges we need to add to make it the full, # extended, 'reachable' graph are: # 1) Partial edges at the fringe: these extend a relatively short way # down a given edge and do not connect to any other partial edges. # 2) \"Internal\" edges that weren't counted originally because they don't # fall on a shortest path, but are still reachable. These edges must # connect nodes on the shortest-path tree - if one node wasn't on the # shortest-path tree and we need to include the whole edge, that edge # should've been on the shortest-path tree (proof to come). edges = list ( edges ) traveled_edges = set (( e [ \"_u\" ], e [ \"_v\" ]) for e in edges ) traveled_nodes = set ([ n for path in paths . values () for n in path ]) if G . is_directed (): neighbor_func = G . successors else : neighbor_func = G . neighbors fringe_candidates = {} for u in traveled_nodes : if u not in G : # For some reason, this only happens to the in-memory graph: the # \"pseudo\" node created in paths that start along an edge remains # and of course does not exist in the true graph. # Investigate: FIXME! continue for v in neighbor_func ( u ): # Ignore already-traveled edges if ( u , v ) in traveled_edges : continue traveled_edges . add (( u , v )) # Determine cost of traversal edge_data = G [ u ][ v ] edge_data = dict ( edge_data ) # FIXME: this value is incorrect for precalculated weights. Need # to maintain precalculated and non-precalculated versions of the # cost function and apply the non-precalculated for these # situations. cost = cost_function ( u , v , edge_data ) # Exclude non-traversible edges if cost is None : continue # If the total cost is still less than max_cost, we will have # traveled the whole edge - there is no new \"pseudo\" node, only a # new edge. if v in nodes and nodes [ v ] . cost + cost < max_cost : interpolate_proportion = 1.0 else : remaining = max_cost - nodes [ u ] . cost interpolate_proportion = remaining / cost # TODO: Use consistent data classes for passing around edge data, # leave (de)serialization concerns up to near-db interfaces edge_data [ \"_u\" ] = u edge_data [ \"_v\" ] = v fringe_candidate : FringeCandidate = { \"cost\" : cost , \"edge_data\" : edge_data , \"proportion\" : interpolate_proportion , } fringe_candidates [( u , v )] = fringe_candidate fringe_edges = [] seen = set () # Don't treat origin point edge as fringe-y: each start point in the # shortest-path tree was reachable from the initial half-edge. # started = list(set([path[0] for target, path in paths.items()])) # Adjust / remove fringe proportions based on context for edge_id , fringe_candidate in fringe_candidates . items (): # Skip already-seen edges (e.g. reverse edges we looked ahead for). if edge_id in seen : continue edge_data = fringe_candidate [ \"edge_data\" ] proportion = fringe_candidate [ \"proportion\" ] cost = fringe_candidate [ \"cost\" ] # Can traverse whole edge - keep it if proportion == 1 : fringe_edges . append ( edge_data ) continue rev_edge_id = ( edge_id [ 1 ], edge_id [ 0 ]) # reverse_intersected = False has_reverse = rev_edge_id in fringe_candidates if has_reverse : # This edge is \"internal\": it's being traversed from both sides rev_proportion = fringe_candidates [ rev_edge_id ][ \"proportion\" ] if proportion + rev_proportion > 1 : # They intersect - the entire edge can be traversed. fringe_edges . append ( edge_data ) continue else : # They do not intersect. Keep the original proportions pass # If this point has been reached, this is: # (1) A partial extension down an edge # (2) It doesn't overlap with any other partial edges # Create primary partial edge and node and append to the saved data fringe_edge , fringe_node = _make_partial_edge ( G , edge_data , proportion ) fringe_edges . append ( fringe_edge ) fringe_node_id = fringe_node . key nodes [ fringe_node_id ] = ReachedNode ( key = fringe_node . key , geom = fringe_node . geom , cost = max_cost ) seen . add ( edge_id ) edges = edges + fringe_edges for edge in edges : geom = edge [ \"geom\" ] if isinstance ( geom , LineString ): edge [ \"geom\" ] = asdict ( geom ) return nodes , edges","title":"reachable_tree()"},{"location":"quickstart/","text":"Quickstart With pip-installed Unweaver Clone the git repo to get an example project directory git clone https://github.com/nbolten/unweaver cd unweaver Build a routable geopackage unweaver build ./example Start the Unweaver web server unweaver serve ./example Get shortest-path routes! curl \"http://localhost:8000/shortest_path/distance.json?lon1=-122.313108&lat1=47.661011&lon2=-122.313170&lat2=47.65724\" With Docker Clone the git repo to get an example project directory git clone https://github.com/nbolten/unweaver cd unweaver Build a routable geopackage docker run --rm -v $(pwd)/example:/project unweaver build /project Start the Unweaver web server docker run --rm -v $(pwd)/example:/project:ro -p 8000:8000 unweaver serve -h 0.0.0.0 /project Get shortest-path routes! curl \"http://localhost:8000/shortest_path/distance.json?lon1=-122.313108&lat1=47.661011&lon2=-122.313170&lat2=47.65724\"","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#with-pip-installed-unweaver","text":"","title":"With pip-installed Unweaver"},{"location":"quickstart/#clone-the-git-repo-to-get-an-example-project-directory","text":"git clone https://github.com/nbolten/unweaver cd unweaver","title":"Clone the git repo to get an example project directory"},{"location":"quickstart/#build-a-routable-geopackage","text":"unweaver build ./example","title":"Build a routable geopackage"},{"location":"quickstart/#start-the-unweaver-web-server","text":"unweaver serve ./example","title":"Start the Unweaver web server"},{"location":"quickstart/#get-shortest-path-routes","text":"curl \"http://localhost:8000/shortest_path/distance.json?lon1=-122.313108&lat1=47.661011&lon2=-122.313170&lat2=47.65724\"","title":"Get shortest-path routes!"},{"location":"quickstart/#with-docker","text":"","title":"With Docker"},{"location":"quickstart/#clone-the-git-repo-to-get-an-example-project-directory_1","text":"git clone https://github.com/nbolten/unweaver cd unweaver","title":"Clone the git repo to get an example project directory"},{"location":"quickstart/#build-a-routable-geopackage_1","text":"docker run --rm -v $(pwd)/example:/project unweaver build /project","title":"Build a routable geopackage"},{"location":"quickstart/#start-the-unweaver-web-server_1","text":"docker run --rm -v $(pwd)/example:/project:ro -p 8000:8000 unweaver serve -h 0.0.0.0 /project","title":"Start the Unweaver web server"},{"location":"quickstart/#get-shortest-path-routes_1","text":"curl \"http://localhost:8000/shortest_path/distance.json?lon1=-122.313108&lat1=47.661011&lon2=-122.313170&lat2=47.65724\"","title":"Get shortest-path routes!"}]}